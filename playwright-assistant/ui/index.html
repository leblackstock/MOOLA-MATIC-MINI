<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Moola Playwright Helper</title>
    <style>
      :root {
        color-scheme: dark;
        font-family: "Segoe UI", Arial, Helvetica, sans-serif;
        --violet-950: #0f0a1d;
        --violet-900: #1b1033;
        --violet-800: #2a1650;
        --violet-700: #3c1e6b;
        --violet-500: #7c3aed;
        --violet-300: #c4b5fd;
        --violet-200: #d8ccff;
        --ink-100: #f4f0ff;
        --ink-200: #d9cff6;
      }

      html,
      body {
        min-height: 100%;
      }
      body {
        margin: 0;
        color: var(--ink-100);
        background: radial-gradient(
          circle at top,
          #22113f 0%,
          #120a22 45%,
          #0b0814 100%
        );
        background-repeat: no-repeat;
        background-attachment: fixed;
      }
      .wrap {
        max-width: 980px;
        margin: 0 auto;
        padding: 28px 22px 48px;
      }
      h1 {
        margin: 0 0 8px;
        font-size: 28px;
        color: var(--ink-100);
      }
      h2 {
        margin: 0 0 10px;
        font-size: 18px;
        color: var(--violet-200);
      }
      p {
        margin: 6px 0 16px;
        color: var(--ink-200);
      }
      .panel {
        border: 1px solid #3a245c;
        border-radius: 14px;
        padding: 16px 18px;
        margin: 14px 0;
        background: rgba(19, 12, 33, 0.9);
        box-shadow: 0 8px 24px rgba(12, 8, 22, 0.7);
      }
      .panel summary {
        cursor: pointer;
        list-style: none;
      }
      .panel summary::-webkit-details-marker {
        display: none;
      }
      .panel summary h2 {
        margin: 0;
      }
      .panel[open] summary {
        margin-bottom: 10px;
      }
      .field {
        margin: 14px 0;
      }
      .field label {
        display: block;
        font-weight: 600;
        margin-bottom: 8px;
        color: var(--violet-200);
      }
      .field label.merged-field {
        color: var(--violet-200);
        text-shadow: none;
      }
      .field.merged-field input,
      .field.merged-field textarea,
      .field.merged-field select {
        box-shadow:
          0 0 0 1px rgba(124, 58, 237, 0.6),
          0 0 10px rgba(124, 58, 237, 0.6),
          0 0 18px rgba(124, 58, 237, 0.35);
      }
      .field input,
      .field textarea,
      .field select {
        width: 100%;
        padding: 10px 12px;
        border: 1px solid #3b2a63;
        border-radius: 10px;
        font-size: 14px;
        box-sizing: border-box;
        background: #1a102b;
        color: var(--ink-100);
      }
      .field input:focus,
      .field textarea:focus {
        outline: 2px solid #5b3a9f;
        border-color: var(--violet-500);
        background: #201236;
      }
      .field textarea {
        min-height: 96px;
        resize: vertical;
      }
      .row {
        display: flex;
        gap: 10px;
        align-items: center;
        flex-wrap: wrap;
      }
      .size-grid {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
      }
      .size-cell {
        display: flex;
        flex-direction: column;
        gap: 6px;
        min-width: 120px;
        flex: 1 1 120px;
      }
      .size-cell-label {
        font-size: 12px;
        color: var(--text-muted);
        font-weight: 600;
        letter-spacing: 0.02em;
      }
      .size-toggles {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
      }
      .measurement-grid {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
      }
      .measurement-grid .field {
        flex: 1 1 calc(33.333% - 10px);
        min-width: 240px;
      }
      .measurement-grid .size-tag-field {
        flex: 1 1 100%;
      }
      .row button {
        padding: 9px 14px;
        border: 1px solid #6b3ddb;
        background: linear-gradient(145deg, #7c3aed, #5b2fc7);
        color: #fff;
        border-radius: 10px;
        cursor: pointer;
        font-weight: 600;
        transition:
          transform 0.05s ease,
          box-shadow 0.15s ease;
      }
      .row button:hover {
        box-shadow: 0 8px 16px rgba(124, 58, 237, 0.35);
      }
      .row button:active {
        transform: translateY(1px);
      }
      .row button:disabled {
        opacity: 0.45;
        cursor: not-allowed;
        background: #3b275e;
        border-color: #3b275e;
        box-shadow: none;
      }
      .note {
        font-size: 12px;
        color: #b29adf;
      }
      .section-title {
        margin: 14px 0 6px;
        font-size: 14px;
        color: var(--violet-200);
        font-weight: 600;
      }
      .inline-check {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        font-size: 12px;
        color: #b29adf;
      }
      .inline-check input {
        width: auto;
      }
      .status {
        margin-top: 8px;
        font-size: 14px;
        color: #bba6e7;
      }
      #fileInput {
        padding: 8px;
        background: #130c21;
        color: var(--ink-100);
        border: 1px solid #3b2a63;
        border-radius: 8px;
      }
    </style>
  </head>
  <body>
    <div class="wrap">
      <h1>Moola Playwright Helper</h1>
      <p>Load your listing JSON, then copy fields into your listing form.</p>
      <div class="row" style="margin: 8px 0 14px">
        <button id="expandAllBtn" type="button">Expand all</button>
        <button id="collapseAllBtn" type="button">Collapse all</button>
        <button id="clearAllBtn" type="button">Clear All</button>
      </div>

      <details id="loaderPanel" class="panel" open>
        <summary><h2>JSON Loader</h2></summary>
        <div class="row">
          <input type="file" id="fileInput" accept=".json" multiple />
          <button id="downloadBtn" disabled>Download JSON</button>
          <button id="previewBtn" disabled>Preview Listing</button>
          <button id="mergeBtn" disabled>Update/Merge JSON</button>
          <button id="terapeakBtn" disabled>Open Terapeak comps</button>
          <button id="prevBtn" disabled>Prev</button>
          <button id="nextBtn" disabled>Next</button>
        </div>
        <input
          id="mergePicker"
          type="file"
          accept=".json"
          style="display: none"
        />
        <div class="note" style="margin-top: 10px">
          Edit mode is always on. Edits update the JSON used for auto‑fill and
          download.
        </div>
        <div class="status" id="status">No file loaded.</div>
        <div class="note">
          Generate JSON with /run-moola List, then load it here to review/edit.
        </div>
        <div class="note">
          This page never shows raw JSON. It only displays copy-ready fields.
        </div>
      </details>

      <details class="panel" id="autofillPanel">
        <summary><h2>Auto‑fill helper</h2></summary>
        <div class="field">
          <label>Project folder path</label>
          <input
            id="projectPathInput"
            type="text"
            placeholder="C:\\Users\\outdo\\Documents\\MOOLA-MATIC MINI"
          />
        </div>
        <div class="field">
          <label>JSON file path</label>
          <input
            id="jsonPathInput"
            type="text"
            placeholder="C:\\Users\\outdo\\Downloads\\listing.json"
          />
        </div>
        <div class="row">
          <input
            id="jsonPicker"
            type="file"
            accept=".json"
            style="display: none"
          />
          <button id="jsonBrowseBtn">Browse JSON</button>
        </div>
        <div class="row">
          <button id="copyCmdBtn">Copy autofill command</button>
          <button id="downloadBatBtn">Download run-autofill.bat</button>
        </div>
        <div class="note" id="autofillNote">
          Browsers can’t run Playwright directly. Use the copied command or the
          .bat file.
        </div>
        <div class="note" style="margin-top: 8px">
          Need PowerShell? Press the Windows key, type "PowerShell", and open
          Windows PowerShell.
        </div>
      </details>

      <details id="skuPanel" class="panel" style="display: none" open>
        <summary><h2>SKU</h2></summary>
        <div class="field">
          <label>SKU</label>
          <div class="row">
            <input id="skuInput" type="text" placeholder="Enter SKU" />
            <button id="skuOkBtn">OK</button>
            <button id="skuChangeBtn">Change</button>
          </div>
          <div class="note" id="skuHint"></div>
        </div>
      </details>

      <details id="lpPanel" class="panel" style="display: none" open>
        <summary><h2>Priority Details</h2></summary>
        <div class="note" style="margin-top: 6px">
          High-priority listing fields for quick review and edits.
        </div>
        <div id="lpFields"></div>
      </details>

      <details
        id="measurementsHelperPanel"
        class="panel"
        style="display: none"
        open
      >
        <summary><h2>Measurements helper</h2></summary>
        <div class="note" style="margin-top: 6px">
          Enter inches; cm is auto-calculated. Auto-generated values use "~".
        </div>
        <div class="section-title">Measurements text fields</div>
        <div id="measurementSummaryFields"></div>
        <div class="field">
          <label>Measurement template</label>
          <select id="measurementTemplateSelect">
            <option value="auto">Auto (detect)</option>
            <option value="shoe">Shoes</option>
            <option value="boot">Boots</option>
            <option value="garment">Garments</option>
            <option value="standard">Standard L/W/H</option>
          </select>
          <div class="row" style="margin-top: 8px">
            <button id="saveMeasurementsBtn" type="button">
              Save measurements
            </button>
          </div>
        </div>
        <div id="shoeFields" class="measurement-grid">
          <div class="field size-tag-field">
            <label>Size Tag</label>
            <div class="size-grid">
              <div class="size-cell">
                <div class="size-cell-label">US M</div>
                <input id="sizeUsMenInput" type="text" placeholder="US M" />
                <div class="size-toggles" id="sizeUsMenToggles"></div>
              </div>
              <div class="size-cell">
                <div class="size-cell-label">US W</div>
                <input id="sizeUsWomenInput" type="text" placeholder="US W" />
                <div class="size-toggles" id="sizeUsWomenToggles"></div>
              </div>
              <div class="size-cell">
                <div class="size-cell-label">UK</div>
                <input id="sizeUkInput" type="text" placeholder="UK" />
                <div class="size-toggles" id="sizeUkToggles"></div>
              </div>
              <div class="size-cell">
                <div class="size-cell-label">EU</div>
                <input id="sizeEuInput" type="text" placeholder="EU" />
                <div class="size-toggles" id="sizeEuToggles"></div>
              </div>
              <div class="size-cell">
                <div class="size-cell-label">AU</div>
                <input id="sizeAuInput" type="text" placeholder="AU" />
                <div class="size-toggles" id="sizeAuToggles"></div>
              </div>
              <div class="size-cell">
                <div class="size-cell-label">Width</div>
                <input
                  id="sizeWidthInput"
                  type="text"
                  placeholder="Width (Reg/Wide/Extra Wide/XXWide/Narrow)"
                />
                <div class="size-toggles" id="sizeWidthToggles"></div>
              </div>
            </div>
            <div class="note">
              Original size drives conversions + Verified. Width only if printed
              (Reg/Wide/Extra Wide/XXWide/Narrow). If blank, Size / Fit shows
              Reg Width.
            </div>
          </div>
          <div class="field">
            <label>Outsole length (heel-to-toe, in)</label>
            <input id="outsoleLengthInput" type="number" step="0.1" />
          </div>
          <div class="field">
            <label>Outsole width (widest part, in)</label>
            <input id="outsoleWidthInput" type="number" step="0.1" />
          </div>
          <div class="field">
            <label>Insole length (heel cup to toe, in)</label>
            <input id="insoleLengthInput" type="number" step="0.1" />
          </div>
          <div class="field">
            <label>Insole width (ball area, in)</label>
            <input id="insoleWidthInput" type="number" step="0.1" />
          </div>
          <div class="field">
            <label>Heel height (floor to top of heel, in)</label>
            <input id="heelHeightInput" type="number" step="0.1" />
          </div>
          <div class="field">
            <label>Platform height (forefoot, in)</label>
            <input id="platformHeightInput" type="number" step="0.1" />
          </div>
          <div class="field">
            <label>Toe box height (inside height at toes, in)</label>
            <input id="toeBoxHeightInput" type="number" step="0.1" />
          </div>
          <div class="field">
            <label>Weight</label>
            <div class="row">
              <input
                id="weightLbInput"
                type="number"
                step="1"
                placeholder="lb"
              />
              <input
                id="weightOzInput"
                type="number"
                step="1"
                placeholder="oz"
              />
              <select id="weightPerSelect">
                <option value="pair">Per pair</option>
                <option value="boot">Per boot</option>
              </select>
            </div>
          </div>
        </div>
        <div id="bootFields" class="measurement-grid">
          <div class="field">
            <label>Shaft height (top of outsole to top, in)</label>
            <input id="shaftHeightInput" type="number" step="0.1" />
          </div>
          <div class="field">
            <label>Shaft opening / circumference (in)</label>
            <input id="shaftCircInput" type="number" step="0.1" />
          </div>
          <div class="field">
            <label>Calf circumference (widest point, in)</label>
            <input id="calfCircInput" type="number" step="0.1" />
          </div>
        </div>
        <div id="garmentFields" class="measurement-grid">
          <div class="field">
            <label>Chest (pit to pit, in)</label>
            <input id="garmentChestInput" type="number" step="0.1" />
          </div>
          <div class="field">
            <label>Length (shoulder to hem, in)</label>
            <input id="garmentLengthInput" type="number" step="0.1" />
          </div>
          <div class="field">
            <label>Shoulder width (in)</label>
            <input id="garmentShoulderInput" type="number" step="0.1" />
          </div>
          <div class="field">
            <label>Sleeve length (in)</label>
            <input id="garmentSleeveInput" type="number" step="0.1" />
          </div>
          <div class="field">
            <label>Waist (in)</label>
            <input id="garmentWaistInput" type="number" step="0.1" />
          </div>
          <div class="field">
            <label>Inseam (in)</label>
            <input id="garmentInseamInput" type="number" step="0.1" />
          </div>
          <div class="field">
            <label>Rise (in)</label>
            <input id="garmentRiseInput" type="number" step="0.1" />
          </div>
          <div class="field">
            <label>Hip (in)</label>
            <input id="garmentHipInput" type="number" step="0.1" />
          </div>
        </div>
        <div id="standardFields" class="measurement-grid">
          <div class="field">
            <label>Length (in)</label>
            <input id="standardLengthInput" type="number" step="0.1" />
          </div>
          <div class="field">
            <label>Width (in)</label>
            <input id="standardWidthInput" type="number" step="0.1" />
          </div>
          <div class="field">
            <label>Height (in)</label>
            <input id="standardHeightInput" type="number" step="0.1" />
          </div>
        </div>
      </details>

      <details id="shippingPanel" class="panel" style="display: none" open>
        <summary><h2>Shipping</h2></summary>
        <div class="note" style="margin-top: 6px">
          Shipping fields used by selectors and autofill.
        </div>
        <div id="shippingFields"></div>
      </details>

      <details id="corePanel" class="panel" style="display: none" open>
        <summary><h2>Core Details</h2></summary>
        <div class="note" style="margin-top: 6px">
          Remaining core listing fields and metadata.
        </div>
        <div id="lpCoreFields"></div>
      </details>

      <details id="platformPanel" class="panel" style="display: none" open>
        <summary><h2>Platform specifics</h2></summary>
        <div class="note" style="margin-top: 6px">
          Platform-specific reasons and types grouped by platform.
        </div>
        <div class="section-title">Ebay</div>
        <div id="ebayPlatformFields"></div>
        <div class="section-title">Depop</div>
        <div id="depopPlatformFields"></div>
        <div class="section-title">Etsy</div>
        <div id="etsyPlatformFields"></div>
        <div class="section-title">Poshmark</div>
        <div id="poshmarkPlatformFields"></div>
        <div class="section-title">Mercari</div>
        <div id="mercariPlatformFields"></div>
        <div class="section-title">Grailed</div>
        <div id="grailedPlatformFields"></div>
        <div class="section-title">Facebook Marketplace</div>
        <div id="facebookPlatformFields"></div>
        <div class="section-title">Shopify</div>
        <div id="shopifyPlatformFields"></div>
        <div class="section-title">Vestiaire Collective</div>
        <div id="vestiairePlatformFields"></div>
        <div class="section-title">Vinted</div>
        <div id="vintedPlatformFields"></div>
        <div class="section-title">Whatnot</div>
        <div id="whatnotPlatformFields"></div>
      </details>

      <details id="additionalPanel" class="panel" style="display: none" open>
        <summary><h2>Additional information</h2></summary>
        <div class="note" style="margin-top: 6px">
          Listing content and other non-selector fields.
        </div>
        <div class="section-title">Misc Types</div>
        <div id="typesMiscFields"></div>
        <div id="additionalFields"></div>
      </details>
    </div>

    <script>
      const fileInput = document.getElementById("fileInput");
      const downloadBtn = document.getElementById("downloadBtn");
      const previewBtn = document.getElementById("previewBtn");
      const mergeBtn = document.getElementById("mergeBtn");
      const terapeakBtn = document.getElementById("terapeakBtn");
      const expandAllBtn = document.getElementById("expandAllBtn");
      const collapseAllBtn = document.getElementById("collapseAllBtn");
      const clearAllBtn = document.getElementById("clearAllBtn");
      const lpPanel = document.getElementById("lpPanel");
      const measurementsHelperPanel = document.getElementById(
        "measurementsHelperPanel",
      );
      const shippingPanel = document.getElementById("shippingPanel");
      const corePanel = document.getElementById("corePanel");
      const platformPanel = document.getElementById("platformPanel");
      const additionalPanel = document.getElementById("additionalPanel");
      const lpFieldsContainer = document.getElementById("lpFields");
      const lpCoreFieldsContainer = document.getElementById("lpCoreFields");
      const measurementSummaryFieldsContainer = document.getElementById(
        "measurementSummaryFields",
      );
      const shippingFieldsContainer = document.getElementById("shippingFields");
      const ebayPlatformFieldsContainer =
        document.getElementById("ebayPlatformFields");
      const depopPlatformFieldsContainer = document.getElementById(
        "depopPlatformFields",
      );
      const etsyPlatformFieldsContainer =
        document.getElementById("etsyPlatformFields");
      const poshmarkPlatformFieldsContainer = document.getElementById(
        "poshmarkPlatformFields",
      );
      const mercariPlatformFieldsContainer = document.getElementById(
        "mercariPlatformFields",
      );
      const grailedPlatformFieldsContainer = document.getElementById(
        "grailedPlatformFields",
      );
      const facebookPlatformFieldsContainer = document.getElementById(
        "facebookPlatformFields",
      );
      const shopifyPlatformFieldsContainer = document.getElementById(
        "shopifyPlatformFields",
      );
      const vestiairePlatformFieldsContainer = document.getElementById(
        "vestiairePlatformFields",
      );
      const vintedPlatformFieldsContainer = document.getElementById(
        "vintedPlatformFields",
      );
      const whatnotPlatformFieldsContainer = document.getElementById(
        "whatnotPlatformFields",
      );
      const typesMiscFieldsContainer =
        document.getElementById("typesMiscFields");
      const additionalFieldsContainer =
        document.getElementById("additionalFields");
      const status = document.getElementById("status");
      const prevBtn = document.getElementById("prevBtn");
      const nextBtn = document.getElementById("nextBtn");
      const projectPathInput = document.getElementById("projectPathInput");
      const jsonPathInput = document.getElementById("jsonPathInput");
      const jsonPicker = document.getElementById("jsonPicker");
      const mergePicker = document.getElementById("mergePicker");
      const jsonBrowseBtn = document.getElementById("jsonBrowseBtn");
      const copyCmdBtn = document.getElementById("copyCmdBtn");
      const downloadBatBtn = document.getElementById("downloadBatBtn");
      const autofillNote = document.getElementById("autofillNote");
      const skuPanel = document.getElementById("skuPanel");
      const skuInput = document.getElementById("skuInput");
      const skuOkBtn = document.getElementById("skuOkBtn");
      const skuChangeBtn = document.getElementById("skuChangeBtn");
      const skuHint = document.getElementById("skuHint");
      const autoMeasurementsToggle = null;
      const measurementTemplateSelect = document.getElementById(
        "measurementTemplateSelect",
      );
      const saveMeasurementsBtn = document.getElementById(
        "saveMeasurementsBtn",
      );
      const shoeFields = document.getElementById("shoeFields");
      const bootFields = document.getElementById("bootFields");
      const garmentFields = document.getElementById("garmentFields");
      const standardFields = document.getElementById("standardFields");
      const sizeUsMenInput = document.getElementById("sizeUsMenInput");
      const sizeUsWomenInput = document.getElementById("sizeUsWomenInput");
      const sizeUkInput = document.getElementById("sizeUkInput");
      const sizeEuInput = document.getElementById("sizeEuInput");
      const sizeAuInput = document.getElementById("sizeAuInput");
      const sizeWidthInput = document.getElementById("sizeWidthInput");
      const sizeUsMenToggles = document.getElementById("sizeUsMenToggles");
      const sizeUsWomenToggles = document.getElementById("sizeUsWomenToggles");
      const sizeUkToggles = document.getElementById("sizeUkToggles");
      const sizeEuToggles = document.getElementById("sizeEuToggles");
      const sizeAuToggles = document.getElementById("sizeAuToggles");
      const sizeWidthToggles = document.getElementById("sizeWidthToggles");
      const outsoleLengthInput = document.getElementById("outsoleLengthInput");
      const outsoleWidthInput = document.getElementById("outsoleWidthInput");
      const insoleLengthInput = document.getElementById("insoleLengthInput");
      const insoleWidthInput = document.getElementById("insoleWidthInput");
      const heelHeightInput = document.getElementById("heelHeightInput");
      const platformHeightInput = document.getElementById(
        "platformHeightInput",
      );
      const toeBoxHeightInput = document.getElementById("toeBoxHeightInput");
      const weightLbInput = document.getElementById("weightLbInput");
      const weightOzInput = document.getElementById("weightOzInput");
      const weightPerSelect = document.getElementById("weightPerSelect");
      const shaftHeightInput = document.getElementById("shaftHeightInput");
      const shaftCircInput = document.getElementById("shaftCircInput");
      const calfCircInput = document.getElementById("calfCircInput");
      const garmentChestInput = document.getElementById("garmentChestInput");
      const garmentLengthInput = document.getElementById("garmentLengthInput");
      const garmentShoulderInput = document.getElementById(
        "garmentShoulderInput",
      );
      const garmentSleeveInput = document.getElementById("garmentSleeveInput");
      const garmentWaistInput = document.getElementById("garmentWaistInput");
      const garmentInseamInput = document.getElementById("garmentInseamInput");
      const garmentRiseInput = document.getElementById("garmentRiseInput");
      const garmentHipInput = document.getElementById("garmentHipInput");
      const standardLengthInput = document.getElementById(
        "standardLengthInput",
      );
      const standardWidthInput = document.getElementById("standardWidthInput");
      const standardHeightInput = document.getElementById(
        "standardHeightInput",
      );
      let lastSizeEdited = null;
      let items = [];
      let currentIndex = 0;
      let currentData = null;
      let skuConfirmed = false;
      let editMode = true;
      let fieldInputs = [];
      let fieldInputMap = {};
      let fieldLabelMap = {};
      let lastAutoNotes = [];
      let lastAutoSize = "";
      let originalSizeRef = null;
      let includeToggles = {};
      let verifiedToggles = {};
      let measurementTogglePairs = [];
      let includeDefaultsApplied = false;
      let mergedFieldKeys = new Set();
      let mergedMeasurementLabelKeys = new Set();
      let defaultJsonFolder = "C:\\\\Users\\\\outdo\\\\Downloads";
      const sessionStorageKey = "moola_session_data";

      function toStringValue(value) {
        if (value === null || value === undefined) return "";
        if (Array.isArray(value)) {
          return value
            .map((item) => {
              if (item && typeof item === "object") {
                const platform = item.platform || "";
                const reason = item.reason || "";
                return platform && reason
                  ? `${platform}: ${reason}`
                  : platform || reason;
              }
              return String(item);
            })
            .join("\n");
        }
        if (typeof value === "object") return JSON.stringify(value);
        return String(value);
      }

      function parseList(value) {
        return String(value || "")
          .split(/[,\n]/)
          .map((item) => item.trim())
          .filter(Boolean);
      }

      function setMergedFieldKeys(keys) {
        mergedFieldKeys = new Set(Array.isArray(keys) ? keys : []);
      }

      function setMergedMeasurementLabelKeys(keys) {
        mergedMeasurementLabelKeys = new Set(Array.isArray(keys) ? keys : []);
      }

      function collectMeasurementLabelKeys(data) {
        if (!data) return [];
        const combined = Array.isArray(data.measurements)
          ? data.measurements
          : parseList(data.measurements);
        const imperial = Array.isArray(data.measurements_imperial)
          ? data.measurements_imperial
          : parseList(data.measurements_imperial);
        const metric = Array.isArray(data.measurements_metric)
          ? data.measurements_metric
          : parseList(data.measurements_metric);
        const lines = [...combined, ...imperial, ...metric];
        const keys = new Set();
        lines.forEach((line) => {
          const labelKey = normalizeMeasurementLabel(line);
          if (labelKey) keys.add(labelKey);
        });
        return [...keys];
      }

      function getMeasurementInputsForLabel(labelKey) {
        switch (labelKey) {
          case "sizefit":
            return [
              sizeUsMenInput,
              sizeUsWomenInput,
              sizeUkInput,
              sizeEuInput,
              sizeAuInput,
              sizeWidthInput,
            ];
          case "outsolelengthheeltoe":
          case "outsolelengthheeltotoe":
          case "outsolelengthheelcuptotoe":
          case "outsolelength":
            return [outsoleLengthInput];
          case "outsolewidthwidest":
          case "outsolewidth":
            return [outsoleWidthInput];
          case "insolelengthheeltoe":
          case "insolelengthheeltotoe":
          case "insolelengthheelcuptotoe":
          case "insolelength":
            return [insoleLengthInput];
          case "insolewidthballarea":
          case "insolewidth":
            return [insoleWidthInput];
          case "heelheight":
            return [heelHeightInput];
          case "platformheightforefoot":
            return [platformHeightInput];
          case "toeboxheight":
            return [toeBoxHeightInput];
          case "shaftheightfromoutsole":
            return [shaftHeightInput];
          case "shaftopeningcircumference":
            return [shaftCircInput];
          case "calfcircumferencewidestpoint":
            return [calfCircInput];
          case "chestpittopit":
            return [garmentChestInput];
          case "lengthshouldertohem":
            return [garmentLengthInput];
          case "shoulderwidth":
            return [garmentShoulderInput];
          case "sleevelength":
            return [garmentSleeveInput];
          case "waist":
            return [garmentWaistInput];
          case "inseam":
            return [garmentInseamInput];
          case "rise":
            return [garmentRiseInput];
          case "hip":
            return [garmentHipInput];
          case "length":
            return [standardLengthInput];
          case "width":
            return [standardWidthInput];
          case "height":
            return [standardHeightInput];
          case "weightpair":
          case "weightperboot":
            return [weightValueInput];
          default:
            return [];
        }
      }

      function getMeasurementToggleKey(labelKey) {
        switch (labelKey) {
          case "sizefit":
            return "size";
          case "outsolelengthheeltoe":
          case "outsolelengthheeltotoe":
          case "outsolelengthheelcuptotoe":
          case "outsolelength":
            return "outsoleLength";
          case "outsolewidthwidest":
          case "outsolewidth":
            return "outsoleWidth";
          case "insolelengthheeltoe":
          case "insolelengthheeltotoe":
          case "insolelengthheelcuptotoe":
          case "insolelength":
            return "insoleLength";
          case "insolewidthballarea":
          case "insolewidth":
            return "insoleWidth";
          case "heelheight":
            return "heelHeight";
          case "platformheightforefoot":
            return "platformHeight";
          case "toeboxheight":
            return "toeBoxHeight";
          case "shaftheightfromoutsole":
            return "shaftHeight";
          case "shaftopeningcircumference":
            return "shaftCirc";
          case "calfcircumferencewidestpoint":
            return "calfCirc";
          case "chestpittopit":
            return "garmentChest";
          case "lengthshouldertohem":
            return "garmentLength";
          case "shoulderwidth":
            return "garmentShoulder";
          case "sleevelength":
            return "garmentSleeve";
          case "waist":
            return "garmentWaist";
          case "inseam":
            return "garmentInseam";
          case "rise":
            return "garmentRise";
          case "hip":
            return "garmentHip";
          case "length":
            return "standardLength";
          case "width":
            return "standardWidth";
          case "height":
            return "standardHeight";
          case "weightpair":
          case "weightperboot":
            return "weight";
          default:
            return "";
        }
      }

      function clearMeasurementInputHighlights() {
        if (!Array.isArray(measurementInputs)) return;
        measurementInputs.forEach((input) => {
          const field = input?.closest(".field");
          if (field) field.classList.remove("merged-field");
        });
      }

      function applyMeasurementInputHighlights() {
        clearMeasurementInputHighlights();
        if (!mergedMeasurementLabelKeys.size) return;
        mergedMeasurementLabelKeys.forEach((labelKey) => {
          const inputs = getMeasurementInputsForLabel(labelKey);
          inputs.forEach((input) => {
            const field = input?.closest(".field");
            if (field) field.classList.add("merged-field");
          });
        });
      }

      function autoEnableIncludeTogglesFromMeasurements(data) {
        if (!data) return;
        const lines = [
          ...collectMeasurementLabelKeys(data).map((labelKey) => labelKey),
        ];
        if (!lines.length) return;
        const keys = new Set();
        lines.forEach((labelKey) => {
          const toggleKey = getMeasurementToggleKey(labelKey);
          if (toggleKey) keys.add(toggleKey);
          if (labelKey.startsWith("weight")) keys.add("weight");
        });
        keys.forEach((key) => {
          const toggle = includeToggles[key];
          if (!toggle) return;
          toggle.checked = true;
          toggle.dataset.manual = "false";
        });
      }

      function applyMergedFieldHighlights() {
        Object.entries(fieldLabelMap).forEach(([key, label]) => {
          if (!label) return;
          const field = label.closest(".field");
          if (!field) return;
          if (mergedFieldKeys.has(key)) {
            label.classList.add("merged-field");
            field.classList.add("merged-field");
          } else {
            label.classList.remove("merged-field");
            field.classList.remove("merged-field");
          }
        });
        applyMeasurementInputHighlights();
      }

      function clearMergedFieldHighlights() {
        setMergedFieldKeys([]);
        setMergedMeasurementLabelKeys([]);
        applyMergedFieldHighlights();
        clearMeasurementInputHighlights();
      }

      function buildTerapeakQuery(data) {
        if (!data) return "";
        const title = String(data.title || "").trim();
        const brand = String(data.brand || "").trim();
        let base = title || brand;
        base = String(base)
          .replace(/\b(us|uk|eu)?\s*\d+(\.\d+)?[a-z]?\b/gi, "")
          .replace(/\b(men'?s|women'?s|mens|womens)\b/gi, "")
          .replace(/\s+/g, " ")
          .trim();
        const extras = [];
        if (Array.isArray(data.style_tags)) {
          extras.push(...data.style_tags);
        }
        const era = String(data.era_status || "").toLowerCase();
        if (era === "vintage" || era === "antique") {
          extras.push(era);
        }
        const intended = Array.isArray(data.intended_for)
          ? data.intended_for
          : [];
        const intendedMap = {
          unisex: "unisex",
          men: "mens",
          women: "womens",
          "unisex kids": "kids",
          girls: "girls",
          boys: "boys",
          babies: "babies",
          maternity: "maternity",
          pets: "pets",
          cats: "cats",
          dogs: "dogs",
          none: "",
        };
        const intendedTokens = intended
          .map((value) => {
            const key = String(value || "")
              .toLowerCase()
              .trim();
            return intendedMap[key] || "";
          })
          .filter(Boolean);
        const baseTokens = base.split(/\s+/).filter(Boolean);
        const extraTokens = extras.join(" ").split(/\s+/).filter(Boolean);
        const brandTokens = brand ? brand.split(/\s+/).filter(Boolean) : [];
        const orderedTokens = [
          ...brandTokens,
          ...intendedTokens,
          ...baseTokens,
          ...extraTokens,
        ];
        const seen = new Set();
        const deduped = [];
        orderedTokens.forEach((token) => {
          const key = token.toLowerCase();
          if (seen.has(key)) return;
          seen.add(key);
          deduped.push(token);
        });
        return deduped.join(" ").trim();
      }

      function buildTerapeakUrl(data) {
        const query = buildTerapeakQuery(data);
        const baseUrl = "https://www.ebay.com/sh/research";
        const tz =
          Intl.DateTimeFormat().resolvedOptions().timeZone ||
          "America/New_York";
        const dayRangeRaw = String(data?.comps_day_range || "").trim();
        const dayRangeNum = Number.parseInt(dayRangeRaw, 10);
        const dayRange =
          Number.isFinite(dayRangeNum) && dayRangeNum > 0 ? dayRangeNum : 365;
        const endDate = Date.now();
        const startDate = endDate - dayRange * 24 * 60 * 60 * 1000;
        const params = new URLSearchParams();
        params.set("marketplace", "EBAY-US");
        if (query) params.set("keywords", query);
        params.set("dayRange", String(dayRange));
        params.set("startDate", String(startDate));
        params.set("endDate", String(endDate));
        params.set("categoryId", "0");
        params.set("offset", "0");
        params.set("limit", "50");
        params.set("tabName", "SOLD");
        params.set("tz", tz);
        params.set("conditions", "USED");
        params.set("buyingOptions", "FIXED_PRICE|BEST_OFFER");
        return `${baseUrl}?${params.toString()}`;
      }

      function normalizeKey(value) {
        return String(value || "")
          .toLowerCase()
          .replace(/[^a-z0-9]/g, "");
      }

      function getTitleTokens(value) {
        return String(value || "")
          .toLowerCase()
          .replace(/[^a-z0-9\s]/g, " ")
          .split(/\s+/)
          .map((token) => token.trim())
          .filter(Boolean)
          .filter(
            (token) =>
              !/^(us|uk|eu|au|m|w)\d+(\.\d+)?$/.test(token) &&
              !/^\d+(\.\d+)?$/.test(token),
          );
      }

      function getTokenOverlapCount(aTokens, bTokens) {
        if (!aTokens.length || !bTokens.length) return 0;
        const bSet = new Set(bTokens);
        let count = 0;
        aTokens.forEach((token) => {
          if (bSet.has(token)) count += 1;
        });
        return count;
      }

      function isBlankString(value) {
        return !String(value || "").trim();
      }

      function isBlankArray(value) {
        if (!Array.isArray(value)) return true;
        if (!value.length) return true;
        return value.every((item) => !String(item || "").trim());
      }

      function normalizeMeasurementLabel(text) {
        const value = String(text || "").trim();
        if (!value) return "";
        const parts = value.split(":");
        const label = parts.length > 1 ? parts[0] : value;
        return normalizeKey(label);
      }

      function mergeMeasurementArrays(baseArray, incomingArray) {
        const baseList = Array.isArray(baseArray) ? baseArray : [];
        const incomingList = Array.isArray(incomingArray) ? incomingArray : [];
        if (!baseList.length && incomingList.length) {
          return {
            merged: incomingList,
            changed: true,
            addedCount: incomingList.length,
            addedLabels: incomingList
              .map((item) => normalizeMeasurementLabel(item))
              .filter(Boolean),
          };
        }
        if (!incomingList.length) {
          return {
            merged: baseList,
            changed: false,
            addedCount: 0,
            addedLabels: [],
          };
        }
        const seen = new Set();
        const merged = [];
        baseList.forEach((item) => {
          const label = normalizeMeasurementLabel(item);
          if (label) seen.add(label);
          if (!String(item || "").trim()) return;
          merged.push(item);
        });
        let changed = merged.length !== baseList.length;
        let addedCount = 0;
        const addedLabels = [];
        incomingList.forEach((item) => {
          if (!String(item || "").trim()) return;
          const label = normalizeMeasurementLabel(item);
          if (label && seen.has(label)) return;
          if (label) seen.add(label);
          merged.push(item);
          changed = true;
          addedCount += 1;
          if (label) addedLabels.push(label);
        });
        return { merged, changed, addedCount, addedLabels };
      }

      function getMatchScore(base, incoming) {
        const pairs = [
          { key: "sku", weight: 2 },
          { key: "title", weight: 2 },
          { key: "brand", weight: 1 },
          { key: "size_or_fit", weight: 1 },
          { key: "upc", weight: 1 },
        ];
        let score = 0;
        pairs.forEach(({ key, weight }) => {
          const a = normalizeKey(base?.[key]);
          const b = normalizeKey(incoming?.[key]);
          if (a && b && a === b) score += weight;
        });
        return score;
      }

      function isLikelySameItem(base, incoming) {
        if (!base || !incoming) return false;
        const skuMatch =
          normalizeKey(base.sku) &&
          normalizeKey(base.sku) === normalizeKey(incoming.sku);
        const titleMatch =
          normalizeKey(base.title) &&
          normalizeKey(base.title) === normalizeKey(incoming.title);
        const titleA = normalizeKey(base.title);
        const titleB = normalizeKey(incoming.title);
        const titlePartialMatch =
          titleA &&
          titleB &&
          (titleA.includes(titleB) || titleB.includes(titleA));
        const brandMatch =
          normalizeKey(base.brand) &&
          normalizeKey(base.brand) === normalizeKey(incoming.brand);
        const baseTokens = getTitleTokens(base.title);
        const incomingTokens = getTitleTokens(incoming.title);
        const overlap = getTokenOverlapCount(baseTokens, incomingTokens);
        const score = getMatchScore(base, incoming);
        if (skuMatch) return true;
        if (titleMatch && brandMatch) return true;
        if (titlePartialMatch && brandMatch) return true;
        if (overlap >= 3 && (brandMatch || !normalizeKey(base.brand))) {
          return true;
        }
        return score >= 3;
      }

      function mergeMissingFields(base, incoming) {
        if (!base || !incoming) return { changed: false, changedKeys: [] };
        let changed = false;
        const changedKeys = [];
        const changedFieldKeys = new Set();
        let measurementLinesAdded = false;
        const measurementAddedLabels = new Set();
        const measurementIncomingLabels = collectMeasurementLabelKeys(incoming);
        const markChanged = (key, detail) => {
          const label = detail ? `${key} (${detail})` : key;
          if (!changedKeys.includes(label)) {
            changedKeys.push(label);
          }
          if (key) {
            changedFieldKeys.add(key);
          }
        };
        if (
          isBlankString(base.purchase_date) &&
          !isBlankString(incoming.purchase_date)
        ) {
          base.purchase_date = incoming.purchase_date;
          changed = true;
          markChanged("purchase_date");
        }
        if (
          isBlankString(base.purchase_location) &&
          !isBlankString(incoming.purchase_location)
        ) {
          base.purchase_location = incoming.purchase_location;
          changed = true;
          markChanged("purchase_location");
        }
        if (isBlankString(base.notes) && !isBlankString(incoming.notes)) {
          base.notes = incoming.notes;
          changed = true;
          markChanged("notes");
        }
        Object.keys(incoming).forEach((key) => {
          const incomingValue = incoming[key];
          if (
            key === "measurements" ||
            key === "measurements_imperial" ||
            key === "measurements_metric"
          ) {
            const {
              merged,
              changed: mergedChanged,
              addedCount,
              addedLabels,
            } = mergeMeasurementArrays(base[key], incomingValue);
            if (mergedChanged) {
              base[key] = merged;
              changed = true;
              const label = addedCount > 0 ? `+${addedCount} lines` : "cleaned";
              markChanged(key, label);
              if (addedCount > 0) {
                measurementLinesAdded = true;
              }
              if (addedLabels.length) {
                addedLabels.forEach((labelKey) =>
                  measurementAddedLabels.add(labelKey),
                );
              }
            }
            return;
          }
          if (key === "platforms") {
            if (!Array.isArray(incomingValue) || !incomingValue.length) return;
            if (!Array.isArray(base.platforms) || !base.platforms.length) {
              base.platforms = incomingValue;
              changed = true;
              markChanged("platforms");
              return;
            }
            const existing = new Set(
              base.platforms
                .map((item) => normalizeKey(item?.platform))
                .filter(Boolean),
            );
            incomingValue.forEach((item) => {
              const name = normalizeKey(item?.platform);
              if (!name || existing.has(name)) return;
              base.platforms.push(item);
              existing.add(name);
              changed = true;
              markChanged("platforms");
            });
            return;
          }
          if (Array.isArray(incomingValue)) {
            if (isBlankArray(base[key]) && !isBlankArray(incomingValue)) {
              base[key] = incomingValue;
              changed = true;
              markChanged(key);
            }
            return;
          }
          if (incomingValue && typeof incomingValue === "object") {
            return;
          }
          if (isBlankString(base[key]) && !isBlankString(incomingValue)) {
            base[key] = incomingValue;
            changed = true;
            markChanged(key);
          }
        });

        if (
          isBlankString(base.tags_line) &&
          !isBlankString(incoming.tags_line)
        ) {
          base.tags_line = incoming.tags_line;
          if (isBlankArray(base.tags)) {
            base.tags = parseList(incoming.tags_line);
          }
          changed = true;
          markChanged("tags_line");
        }
        if (isBlankArray(base.tags) && !isBlankArray(incoming.tags)) {
          base.tags = incoming.tags;
          changed = true;
          markChanged("tags");
        }
        return {
          changed,
          changedKeys,
          changedFieldKeys: [...changedFieldKeys],
          measurementLinesAdded,
          measurementAddedLabels: [...measurementAddedLabels],
          measurementIncomingLabels,
        };
      }

      function capitalizeWords(text) {
        return String(text || "")
          .toLowerCase()
          .split(/\s+/)
          .map((word) => (word ? word[0].toUpperCase() + word.slice(1) : ""))
          .join(" ")
          .trim();
      }

      function normalizeColorTags(value) {
        const tags = parseList(value);
        if (!tags.length) return "";
        return tags.map((tag) => capitalizeWords(tag)).join(", ");
      }

      function parseLines(value) {
        return String(value || "")
          .split(/\\n/)
          .map((item) => item.trim())
          .filter(Boolean);
      }

      function parsePlatforms(value) {
        const lines = String(value || "")
          .split(/\\n/)
          .map((line) => line.trim())
          .filter(Boolean);
        return lines.map((line) => {
          const idx = line.indexOf(":");
          if (idx === -1) {
            return { platform: line, reason: "" };
          }
          return {
            platform: line.slice(0, idx).trim(),
            reason: line.slice(idx + 1).trim(),
          };
        });
      }

      function getTypesParts(data) {
        const text = String(data?.types_block || "");
        const depopMatch = text.match(
          /^(?:Depop Boots Type|Depop Shoes Type|Depop Types):\s*(.+)$/im,
        );
        const ebayMatch = text.match(
          /^(?:Ebay Boots Type|Ebay Shoes Type|Ebay Types):\s*(.+)$/im,
        );
        const occasionsMatch = text.match(/^Occasions:\s*(.+)$/im);
        const stylesMatch = text.match(/^Styles:\s*(.+)$/im);
        const depop = depopMatch ? depopMatch[1].trim() : "";
        const ebay = ebayMatch ? ebayMatch[1].trim() : "";
        const occasions = occasionsMatch ? occasionsMatch[1].trim() : "";
        const styles = stylesMatch ? stylesMatch[1].trim() : "";
        const isShoes = /depop shoes type:|ebay shoes type:/i.test(text);
        const isBoots = /depop boots type:|ebay boots type:/i.test(text);
        const depopLabel = depopMatch
          ? String(depopMatch[0]).split(":")[0].trim()
          : "";
        const ebayLabel = ebayMatch
          ? String(ebayMatch[0]).split(":")[0].trim()
          : "";
        const lines = text
          .split(/\\n/)
          .map((line) => line.trim())
          .filter(Boolean);
        const misc = lines.filter((line) => {
          const lower = line.toLowerCase();
          if (lower.startsWith("depop boots type:")) return false;
          if (lower.startsWith("depop shoes type:")) return false;
          if (lower.startsWith("depop types:")) return false;
          if (lower.startsWith("ebay boots type:")) return false;
          if (lower.startsWith("ebay shoes type:")) return false;
          if (lower.startsWith("ebay types:")) return false;
          if (lower.startsWith("occasions:")) return false;
          if (lower.startsWith("styles:")) return false;
          return true;
        });
        return {
          depop,
          ebay,
          occasions,
          styles,
          misc,
          isShoes,
          isBoots,
          depopLabel,
          ebayLabel,
        };
      }

      function buildTypesBlock(parts) {
        const lines = [];
        if (parts.depop) {
          const label =
            parts.depopLabel ||
            (parts.isShoes ? "Depop Shoes Type" : "Depop Boots Type");
          lines.push(`${label}: ${parts.depop}`);
        }
        if (parts.ebay) {
          const label =
            parts.ebayLabel ||
            (parts.isShoes ? "Ebay Shoes Type" : "Ebay Boots Type");
          lines.push(`${label}: ${parts.ebay}`);
        }
        if (parts.occasions) {
          lines.push(`Occasions: ${parts.occasions}`);
        }
        if (parts.styles) {
          lines.push(`Styles: ${parts.styles}`);
        }
        if (parts.misc?.length) {
          lines.push(...parts.misc);
        }
        return lines.join("\\n");
      }

      function setTypesPart(data, part, value) {
        if (!data) return;
        const parts = getTypesParts(data);
        if (part === "depop") parts.depop = String(value || "").trim();
        if (part === "ebay") parts.ebay = String(value || "").trim();
        if (part === "occasions") parts.occasions = String(value || "").trim();
        if (part === "styles") parts.styles = String(value || "").trim();
        if (part === "misc") {
          parts.misc = String(value || "")
            .split(/\\n/)
            .map((line) => line.trim())
            .filter(Boolean);
        }
        data.types_block = buildTypesBlock(parts);
      }

      function getPlatformReason(data, platform) {
        const list = Array.isArray(data?.platforms) ? data.platforms : [];
        const match = list.find(
          (item) =>
            String(item?.platform || "").toLowerCase() ===
            platform.toLowerCase(),
        );
        return match?.reason || "";
      }

      function setPlatformReason(data, platform, reason) {
        if (!data) return;
        const trimmed = String(reason || "").trim();
        const list = Array.isArray(data.platforms) ? data.platforms : [];
        const idx = list.findIndex(
          (item) =>
            String(item?.platform || "").toLowerCase() ===
            platform.toLowerCase(),
        );
        if (!trimmed) {
          if (idx >= 0) list.splice(idx, 1);
          data.platforms = list;
          return;
        }
        if (idx >= 0) {
          list[idx].reason = trimmed;
        } else {
          list.push({ platform, reason: trimmed });
        }
        data.platforms = list;
      }

      function buildPlatformReasonField(platform, labelOverride) {
        return {
          label: labelOverride || `${platform} reason`,
          multiline: true,
          getValue: (data) => getPlatformReason(data, platform),
          setValue: (data, value) => setPlatformReason(data, platform, value),
        };
      }

      function buildListperfectlyDescription(data) {
        const parts = [];
        const hook = String(data?.hook || "").trim();
        if (hook) parts.push(hook);

        const description = String(data?.description || "").trim();
        if (description) parts.push(description);

        const includedItems = Array.isArray(data?.included_items)
          ? data.included_items
          : parseLines(data?.included_items);
        const cleanIncluded = includedItems
          .map((item) => String(item || "").trim())
          .filter(Boolean);
        if (cleanIncluded.length) {
          parts.push(
            `You will receive the following item(s):\n${cleanIncluded
              .map((item) => `- ${item}`)
              .join("\n")}`,
          );
        }

        const measurements = Array.isArray(data?.measurements)
          ? data.measurements
          : parseList(data?.measurements);
        const cleanMeasurements = measurements
          .map((item) => String(item || "").trim())
          .filter(Boolean);
        if (cleanMeasurements.length) {
          parts.push(
            `Measurements:\n${cleanMeasurements
              .map((item) => `- ${item}`)
              .join("\n")}`,
          );
        }

        const cta = String(data?.cta || "").trim();
        if (cta) parts.push(cta);

        return parts.join("\n\n").trim();
      }

      function updateListperfectlyDescription(data) {
        if (!data) return;
        const next = buildListperfectlyDescription(data);
        data.listperfectly_description = next;
        const input = fieldInputMap.listperfectly_description;
        if (input && input.value !== next) {
          input.value = next;
          updateCharCounter("listperfectly_description");
        }
      }

      function stripOfferRecommendation(value) {
        const text = String(value || "").trim();
        if (!text) return "";
        return text.replace(/^offer recommendation\s*[:\-]?\s*/i, "").trim();
      }

      function getAutoSellerNotes(data) {
        if (!data) return [];
        const base =
          data?.purchase_date && data?.purchase_location
            ? `${data.purchase_date} Purchased from ${data.purchase_location}`
            : "";
        const offerLine = stripOfferRecommendation(data?.offer_recommendation);
        return [offerLine, base].filter(Boolean);
      }

      function buildSellerNotes(data, existingNotes) {
        const autoNotes = getAutoSellerNotes(data);
        const lines = String(existingNotes || "")
          .split(/\n/)
          .map((line) => line.trim())
          .filter(Boolean);
        const previousAutoNotes = Array.isArray(lastAutoNotes)
          ? lastAutoNotes
          : [lastAutoNotes].filter(Boolean);
        const extras = lines.filter(
          (line) =>
            !autoNotes.includes(line) && !previousAutoNotes.includes(line),
        );
        if (!autoNotes.length) return extras.join("\n");
        return [...autoNotes, ...extras].join("\n").trim();
      }

      function updateSellerNotes(data) {
        if (!data) return;
        const autoNotes = getAutoSellerNotes(data);
        const next = buildSellerNotes(data, data.notes);
        lastAutoNotes = autoNotes;
        data.notes = next;
        const input = fieldInputMap.notes;
        if (input && input.value !== next) {
          input.value = next;
        }
      }

      function normalizeMsrp(data) {
        if (!data) return;
        const priceRaw = String(data.buyer_pays_shipping_price || "").trim();
        const msrpRaw = String(data.msrp || "").trim();
        const price = parseMoney(priceRaw);
        const msrp = parseMoney(msrpRaw);
        if (price === null) return;
        if (msrp === null || msrp < price) {
          const next = priceRaw || price.toFixed(2);
          data.msrp = next;
          const input = fieldInputMap.msrp;
          if (input && input.value !== next) {
            input.value = next;
          }
        }
      }

      function createInlineToggle(toggleId, labelText) {
        const label = document.createElement("label");
        label.className = "inline-check";
        const checkbox = document.createElement("input");
        checkbox.type = "checkbox";
        checkbox.id = toggleId;
        checkbox.addEventListener("change", () => {
          checkbox.dataset.manual = "true";
        });
        label.appendChild(checkbox);
        label.appendChild(document.createTextNode(` ${labelText}`));
        return { label, checkbox };
      }

      function setToggleChecked(toggle, checked) {
        if (!toggle) return;
        if (toggle.dataset.manual === "true") return;
        toggle.checked = checked;
        toggle.dataset.manual = "false";
      }

      function ensureMeasurementToggles({
        input,
        key,
        includeId,
        verifiedId,
        includeLabel,
        verifiedLabel,
        rowLabel,
        container,
      }) {
        if (!input) return { includeToggle: null, verifiedToggle: null };
        const existingInclude = document.getElementById(includeId);
        const existingVerified = document.getElementById(verifiedId);
        if (existingInclude || existingVerified) {
          includeToggles[key] = existingInclude || null;
          verifiedToggles[key] = existingVerified || null;
          measurementTogglePairs.push({
            input,
            key,
            includeToggle: existingInclude || null,
            verifiedToggle: existingVerified || null,
          });
          return {
            includeToggle: existingInclude || null,
            verifiedToggle: existingVerified || null,
          };
        }
        const field = container || input.closest(".field");
        if (!field) return { includeToggle: null, verifiedToggle: null };
        const row = document.createElement("div");
        row.className = "row";
        if (rowLabel) {
          const label = document.createElement("div");
          label.className = "note";
          label.textContent = rowLabel;
          row.appendChild(label);
        }
        const includeToggle = createInlineToggle(includeId, includeLabel);
        const verifiedToggle = createInlineToggle(verifiedId, verifiedLabel);
        row.appendChild(includeToggle.label);
        row.appendChild(verifiedToggle.label);
        field.appendChild(row);
        includeToggle.checkbox.checked = Boolean(
          String(input.value || "").trim(),
        );
        includeToggle.checkbox.dataset.manual = "false";
        verifiedToggle.checkbox.checked = false;
        verifiedToggle.checkbox.dataset.manual = "false";
        measurementTogglePairs.push({
          input,
          key,
          includeToggle: includeToggle.checkbox,
          verifiedToggle: verifiedToggle.checkbox,
        });
        includeToggles[key] = includeToggle.checkbox;
        verifiedToggles[key] = verifiedToggle.checkbox;
        return {
          includeToggle: includeToggle.checkbox,
          verifiedToggle: verifiedToggle.checkbox,
        };
      }

      function applyIncludeDefaultsFromInputs() {
        if (includeDefaultsApplied) return;
        measurementTogglePairs.forEach(
          ({ includeToggle, verifiedToggle, input }) => {
            if (!input) return;
            if (includeToggle) {
              const hasValue =
                input === weightLbInput
                  ? getWeightPartsFromInputs().hasValue
                  : Boolean(String(input.value || "").trim());
              if (input === sizeWidthInput) {
                includeToggle.checked = true;
              } else {
                includeToggle.checked = hasValue;
              }
              includeToggle.dataset.manual = "false";
            }
            if (verifiedToggle) {
              verifiedToggle.checked = false;
              verifiedToggle.dataset.manual = "false";
            }
          },
        );
        syncSizeVerifiedDefaults(
          convertSizeValues(getRawSizeInputs(), currentData, lastSizeEdited),
        );
        includeDefaultsApplied = true;
      }

      function updateIncludeToggleForInput(input) {
        if (!input) return;
        const targetInput = input === weightOzInput ? weightLbInput : input;
        const pair = measurementTogglePairs.find(
          (item) => item.input === targetInput,
        );
        if (!pair || !pair.includeToggle) return;
        const hasValue =
          targetInput === weightLbInput
            ? getWeightPartsFromInputs().hasValue
            : Boolean(String(input.value || "").trim());
        const isSizeInput = [
          sizeUsMenInput,
          sizeUsWomenInput,
          sizeUkInput,
          sizeEuInput,
          sizeAuInput,
          sizeWidthInput,
        ].includes(targetInput);
        if (!hasValue) {
          if (targetInput !== sizeWidthInput) {
            pair.includeToggle.checked = false;
            pair.includeToggle.dataset.manual = "false";
          } else if (pair.includeToggle.dataset.manual !== "true") {
            pair.includeToggle.checked = true;
          }
          if (pair.verifiedToggle) {
            pair.verifiedToggle.checked = false;
            pair.verifiedToggle.dataset.manual = "false";
          }
          return;
        }
        if (
          pair.includeToggle.dataset.manual === "true" &&
          !pair.includeToggle.checked
        ) {
          return;
        }
        pair.includeToggle.checked = true;
        if (pair.verifiedToggle && !isSizeInput) {
          pair.verifiedToggle.checked = true;
          pair.verifiedToggle.dataset.manual = "true";
        }
      }

      function syncSizeVerifiedDefaults(values) {
        const resolved =
          values ||
          convertSizeValues(getRawSizeInputs(), currentData, lastSizeEdited);
        const baseKey = resolved?.source || null;
        [
          { sourceKey: "us_m", value: resolved?.usMen, toggleKey: "sizeUsMen" },
          {
            sourceKey: "us_w",
            value: resolved?.usWomen,
            toggleKey: "sizeUsWomen",
          },
          { sourceKey: "uk", value: resolved?.uk, toggleKey: "sizeUk" },
          { sourceKey: "eu", value: resolved?.eu, toggleKey: "sizeEu" },
          { sourceKey: "au", value: resolved?.au, toggleKey: "sizeAu" },
        ].forEach(({ sourceKey, value, toggleKey }) => {
          const toggle = verifiedToggles[toggleKey];
          if (!toggle) return;
          if (value === null || Number.isNaN(value)) {
            setToggleChecked(toggle, false);
            return;
          }
          setToggleChecked(toggle, sourceKey === baseKey);
        });
        const widthToggle = verifiedToggles.sizeWidth;
        if (widthToggle) {
          const hasWidth = Boolean(String(sizeWidthInput?.value || "").trim());
          if (originalSizeRef) {
            setToggleChecked(widthToggle, Boolean(originalSizeRef.width));
          } else {
            setToggleChecked(widthToggle, hasWidth);
          }
        }
      }

      function initMeasurementToggles() {
        ensureMeasurementToggles({
          input: sizeUsMenInput,
          key: "sizeUsMen",
          includeId: "sizeUsMenInclude",
          verifiedId: "sizeUsMenVerified",
          includeLabel: "Include",
          verifiedLabel: "Verified",
          container: sizeUsMenToggles,
        });
        ensureMeasurementToggles({
          input: sizeUsWomenInput,
          key: "sizeUsWomen",
          includeId: "sizeUsWomenInclude",
          verifiedId: "sizeUsWomenVerified",
          includeLabel: "Include",
          verifiedLabel: "Verified",
          container: sizeUsWomenToggles,
        });
        ensureMeasurementToggles({
          input: sizeUkInput,
          key: "sizeUk",
          includeId: "sizeUkInclude",
          verifiedId: "sizeUkVerified",
          includeLabel: "Include",
          verifiedLabel: "Verified",
          container: sizeUkToggles,
        });
        ensureMeasurementToggles({
          input: sizeEuInput,
          key: "sizeEu",
          includeId: "sizeEuInclude",
          verifiedId: "sizeEuVerified",
          includeLabel: "Include",
          verifiedLabel: "Verified",
          container: sizeEuToggles,
        });
        ensureMeasurementToggles({
          input: sizeAuInput,
          key: "sizeAu",
          includeId: "sizeAuInclude",
          verifiedId: "sizeAuVerified",
          includeLabel: "Include",
          verifiedLabel: "Verified",
          container: sizeAuToggles,
        });
        ensureMeasurementToggles({
          input: sizeWidthInput,
          key: "sizeWidth",
          includeId: "sizeWidthInclude",
          verifiedId: "sizeWidthVerified",
          includeLabel: "Include",
          verifiedLabel: "Verified",
          container: sizeWidthToggles,
        });
        ensureMeasurementToggles({
          input: outsoleLengthInput,
          key: "outsoleLength",
          includeId: "outsoleLengthInclude",
          verifiedId: "outsoleLengthVerified",
          includeLabel: "Include",
          verifiedLabel: "Verified",
        });
        ensureMeasurementToggles({
          input: outsoleWidthInput,
          key: "outsoleWidth",
          includeId: "outsoleWidthInclude",
          verifiedId: "outsoleWidthVerified",
          includeLabel: "Include",
          verifiedLabel: "Verified",
        });
        ensureMeasurementToggles({
          input: insoleLengthInput,
          key: "insoleLength",
          includeId: "insoleLengthInclude",
          verifiedId: "insoleLengthVerified",
          includeLabel: "Include",
          verifiedLabel: "Verified",
        });
        ensureMeasurementToggles({
          input: insoleWidthInput,
          key: "insoleWidth",
          includeId: "insoleWidthInclude",
          verifiedId: "insoleWidthVerified",
          includeLabel: "Include",
          verifiedLabel: "Verified",
        });
        ensureMeasurementToggles({
          input: heelHeightInput,
          key: "heelHeight",
          includeId: "heelHeightInclude",
          verifiedId: "heelHeightVerified",
          includeLabel: "Include",
          verifiedLabel: "Verified",
        });
        ensureMeasurementToggles({
          input: platformHeightInput,
          key: "platformHeight",
          includeId: "platformHeightInclude",
          verifiedId: "platformHeightVerified",
          includeLabel: "Include",
          verifiedLabel: "Verified",
        });
        ensureMeasurementToggles({
          input: toeBoxHeightInput,
          key: "toeBoxHeight",
          includeId: "toeBoxHeightInclude",
          verifiedId: "toeBoxHeightVerified",
          includeLabel: "Include",
          verifiedLabel: "Verified",
        });
        ensureMeasurementToggles({
          input: weightLbInput,
          key: "weight",
          includeId: "weightInclude",
          verifiedId: "weightVerified",
          includeLabel: "Include",
          verifiedLabel: "Verified",
        });
        ensureMeasurementToggles({
          input: shaftHeightInput,
          key: "shaftHeight",
          includeId: "shaftHeightInclude",
          verifiedId: "shaftHeightVerified",
          includeLabel: "Include",
          verifiedLabel: "Verified",
        });
        ensureMeasurementToggles({
          input: shaftCircInput,
          key: "shaftCirc",
          includeId: "shaftCircInclude",
          verifiedId: "shaftCircVerified",
          includeLabel: "Include",
          verifiedLabel: "Verified",
        });
        ensureMeasurementToggles({
          input: calfCircInput,
          key: "calfCirc",
          includeId: "calfCircInclude",
          verifiedId: "calfCircVerified",
          includeLabel: "Include",
          verifiedLabel: "Verified",
        });
        ensureMeasurementToggles({
          input: garmentChestInput,
          key: "garmentChest",
          includeId: "garmentChestInclude",
          verifiedId: "garmentChestVerified",
          includeLabel: "Include",
          verifiedLabel: "Verified",
        });
        ensureMeasurementToggles({
          input: garmentLengthInput,
          key: "garmentLength",
          includeId: "garmentLengthInclude",
          verifiedId: "garmentLengthVerified",
          includeLabel: "Include",
          verifiedLabel: "Verified",
        });
        ensureMeasurementToggles({
          input: garmentShoulderInput,
          key: "garmentShoulder",
          includeId: "garmentShoulderInclude",
          verifiedId: "garmentShoulderVerified",
          includeLabel: "Include",
          verifiedLabel: "Verified",
        });
        ensureMeasurementToggles({
          input: garmentSleeveInput,
          key: "garmentSleeve",
          includeId: "garmentSleeveInclude",
          verifiedId: "garmentSleeveVerified",
          includeLabel: "Include",
          verifiedLabel: "Verified",
        });
        ensureMeasurementToggles({
          input: garmentWaistInput,
          key: "garmentWaist",
          includeId: "garmentWaistInclude",
          verifiedId: "garmentWaistVerified",
          includeLabel: "Include",
          verifiedLabel: "Verified",
        });
        ensureMeasurementToggles({
          input: garmentInseamInput,
          key: "garmentInseam",
          includeId: "garmentInseamInclude",
          verifiedId: "garmentInseamVerified",
          includeLabel: "Include",
          verifiedLabel: "Verified",
        });
        ensureMeasurementToggles({
          input: garmentRiseInput,
          key: "garmentRise",
          includeId: "garmentRiseInclude",
          verifiedId: "garmentRiseVerified",
          includeLabel: "Include",
          verifiedLabel: "Verified",
        });
        ensureMeasurementToggles({
          input: garmentHipInput,
          key: "garmentHip",
          includeId: "garmentHipInclude",
          verifiedId: "garmentHipVerified",
          includeLabel: "Include",
          verifiedLabel: "Verified",
        });
        ensureMeasurementToggles({
          input: standardLengthInput,
          key: "standardLength",
          includeId: "standardLengthInclude",
          verifiedId: "standardLengthVerified",
          includeLabel: "Include",
          verifiedLabel: "Verified",
        });
        ensureMeasurementToggles({
          input: standardWidthInput,
          key: "standardWidth",
          includeId: "standardWidthInclude",
          verifiedId: "standardWidthVerified",
          includeLabel: "Include",
          verifiedLabel: "Verified",
        });
        ensureMeasurementToggles({
          input: standardHeightInput,
          key: "standardHeight",
          includeId: "standardHeightInclude",
          verifiedId: "standardHeightVerified",
          includeLabel: "Include",
          verifiedLabel: "Verified",
        });
      }

      function isIncluded(toggle) {
        return !toggle || toggle.checked;
      }

      function isVerified(toggle) {
        return Boolean(toggle && toggle.checked);
      }

      function parseNumber(value) {
        const parsed = Number.parseFloat(String(value || ""));
        return Number.isFinite(parsed) ? parsed : null;
      }

      function parseMoney(value) {
        const cleaned = String(value || "").replace(/[^0-9.]/g, "");
        const parsed = Number.parseFloat(cleaned);
        return Number.isFinite(parsed) ? parsed : null;
      }

      function getOriginalSizeReference(data) {
        const original = data?.original_size;
        if (!original || typeof original !== "object") return null;
        const system = String(original.system || "").trim().toUpperCase();
        const sizeValue = parseNumber(original.size);
        if (!system || sizeValue === null) return null;
        const gender = String(original.gender || "").trim().toLowerCase();
        const width = normalizeWidthCode(original.width || "");
        let key = null;
        if (system === "US") {
          key = gender === "women" ? "us_w" : "us_m";
        } else if (system === "UK") {
          key = "uk";
        } else if (system === "EU") {
          key = "eu";
        } else if (system === "AU") {
          key = "au";
        }
        if (!key) return null;
        return { key, size: sizeValue, width, system, gender };
      }

      function applyOriginalSizeReference(data, options = {}) {
        const { preserveExisting = false } = options;
        const reference = getOriginalSizeReference(data);
        originalSizeRef = reference;
        if (!reference) return false;
        const inputMap = {
          us_m: sizeUsMenInput,
          us_w: sizeUsWomenInput,
          uk: sizeUkInput,
          eu: sizeEuInput,
          au: sizeAuInput,
        };
        const target = inputMap[reference.key];
        if (target) {
          if (preserveExisting) {
            setInputValue(target, reference.size);
          } else {
            target.value = reference.size;
            clearOtherSizeInputs(target);
          }
          updateIncludeToggleForInput(target);
        }
        if (sizeWidthInput) {
          if (preserveExisting) {
            if (reference.width) setInputValue(sizeWidthInput, reference.width);
          } else {
            sizeWidthInput.value = reference.width || "";
          }
          updateIncludeToggleForInput(sizeWidthInput);
        }
        lastSizeEdited = reference.key;
        if (data) data.last_size_edited = reference.key;
        return true;
      }

      function formatSizeValue(value, estimated, verified) {
        if (value === null) return null;
        const text = formatNumber(value, 1);
        if (verified) return text;
        return estimated ? `~${text}` : text;
      }

      function getIntendedForValues(data) {
        const input = fieldInputMap?.intended_for;
        const inputValues = input ? parseList(input.value) : [];
        if (inputValues.length) return inputValues;
        return Array.isArray(data?.intended_for) ? data.intended_for : [];
      }

      function getSizeOffsets(data) {
        const intended = getIntendedForValues(data).map((item) =>
          String(item).toLowerCase(),
        );
        const isUnisex = intended.includes("unisex");
        const isWomen = intended.includes("women") && !isUnisex;
        if (isWomen) {
          return { usToUk: -2, usToEu: 31, usToAu: 0 };
        }
        return { usToUk: -1, usToEu: 32, usToAu: -1 };
      }

      function getPreferredUsType(data) {
        const intended = getIntendedForValues(data).map((item) =>
          String(item).toLowerCase(),
        );
        const isUnisex = intended.includes("unisex");
        const isWomen = intended.includes("women") && !isUnisex;
        return isWomen ? "women" : "men";
      }

      function getSizeOffsetsForUsType(data, usType) {
        if (usType === "women") {
          return { usToUk: -2, usToEu: 31, usToAu: 0 };
        }
        return getSizeOffsets(data);
      }

      function roundToNearestHalf(value) {
        if (value === null || Number.isNaN(value)) return null;
        return Math.round(value * 2) / 2;
      }

      function getRawSizeInputs() {
        return {
          usMen: parseNumber(sizeUsMenInput?.value),
          usWomen: parseNumber(sizeUsWomenInput?.value),
          uk: parseNumber(sizeUkInput?.value),
          eu: parseNumber(sizeEuInput?.value),
          au: parseNumber(sizeAuInput?.value),
        };
      }

      function resolveSizeBase(raw, preferred, data) {
        const hasValue = (value) => value !== null;
        if (preferred === "us") preferred = "us_m";
        if (preferred && hasValue(raw[preferred])) return preferred;
        const preferredUsType = data ? getPreferredUsType(data) : "men";
        if (preferredUsType === "women") {
          if (hasValue(raw.usWomen)) return "us_w";
          if (hasValue(raw.usMen)) return "us_m";
        } else {
          if (hasValue(raw.usMen)) return "us_m";
          if (hasValue(raw.usWomen)) return "us_w";
        }
        if (hasValue(raw.uk)) return "uk";
        if (hasValue(raw.au)) return "au";
        if (hasValue(raw.eu)) return "eu";
        return null;
      }

      function convertSizeValues(raw, data, preferred) {
        let { usMen, usWomen, uk, eu, au } = raw;
        let estimated = {
          usMen: false,
          usWomen: false,
          uk: false,
          eu: false,
          au: false,
        };
        const source = resolveSizeBase(raw, preferred, data);
        if (!source) return { usMen, usWomen, uk, eu, au, estimated, source };

        if (source === "us_m" || source === "us_w") {
          const usType = source === "us_w" ? "women" : "men";
          const baseUs = source === "us_w" ? usWomen : usMen;
          const offsets = getSizeOffsetsForUsType(data, usType);
          uk = baseUs + offsets.usToUk;
          estimated.uk = true;
          eu = baseUs + offsets.usToEu;
          estimated.eu = true;
          au = baseUs + offsets.usToAu;
          estimated.au = true;
        } else {
          const usType = getPreferredUsType(data);
          const offsets = getSizeOffsetsForUsType(data, usType);
          let baseUs = null;
          if (source === "uk") {
            baseUs = uk - offsets.usToUk;
          } else if (source === "au") {
            baseUs = au - offsets.usToAu;
          } else if (source === "eu") {
            baseUs = eu - offsets.usToEu;
          }
          if (baseUs !== null) {
            if (usType === "women") {
              usWomen = baseUs;
              estimated.usWomen = true;
            } else {
              usMen = baseUs;
              estimated.usMen = true;
            }
            uk = baseUs + offsets.usToUk;
            estimated.uk = true;
            eu = baseUs + offsets.usToEu;
            estimated.eu = true;
            au = baseUs + offsets.usToAu;
            estimated.au = true;
          }
        }
        usMen = roundToNearestHalf(usMen);
        usWomen = roundToNearestHalf(usWomen);
        uk = roundToNearestHalf(uk);
        eu = roundToNearestHalf(eu);
        au = roundToNearestHalf(au);
        return { usMen, usWomen, uk, eu, au, estimated, source };
      }

      function setSizeInputValue(input, value, sourceKey, inputKey) {
        if (!input || value === null || Number.isNaN(value)) return;
        if (sourceKey && inputKey === sourceKey) return;
        input.value = value;
        updateIncludeToggleForInput(input);
      }

      function applySizeConversions(data, rawOverride, options = {}) {
        const { writeBack = true } = options;
        const raw = rawOverride || getRawSizeInputs();
        const values = convertSizeValues(raw, data, lastSizeEdited);
        if (writeBack) {
          setSizeInputValue(
            sizeUsMenInput,
            values.usMen,
            values.source,
            "us_m",
          );
          setSizeInputValue(
            sizeUsWomenInput,
            values.usWomen,
            values.source,
            "us_w",
          );
          setSizeInputValue(sizeUkInput, values.uk, values.source, "uk");
          setSizeInputValue(sizeEuInput, values.eu, values.source, "eu");
          setSizeInputValue(sizeAuInput, values.au, values.source, "au");
        }
        syncSizeVerifiedDefaults(values);
        return values;
      }

      function shouldAutofillConvertedSizes(raw, source) {
        if (!source) return false;
        const keyMap = {
          us_m: "usMen",
          us_w: "usWomen",
          uk: "uk",
          eu: "eu",
          au: "au",
        };
        return Object.entries(keyMap).every(([sourceKey, rawKey]) => {
          if (sourceKey === source) return true;
          return raw?.[rawKey] === null;
        });
      }

      function normalizeWidthLabel(value) {
        const raw = String(value || "").trim();
        if (!raw) return "";
        const lower = raw.toLowerCase();
        if (lower === "reg" || lower === "regular" || lower === "m") {
          return "Reg";
        }
        if (lower.includes("narrow")) return "Narrow";
        if (
          lower.includes("xx") ||
          lower.includes("4e") ||
          lower.includes("eeee")
        ) {
          return "XXWide";
        }
        if (lower.includes("extra")) return "Extra Wide";
        if (lower.includes("wide") || lower === "w") return "Wide";
        const compact = lower.replace(/[^a-z0-9]/g, "");
        if (compact === "d") return "Reg";
        if (compact === "b" || compact === "c") return "Narrow";
        if (compact === "e" || compact === "ee" || compact === "2e") {
          return "Wide";
        }
        if (compact === "eee" || compact === "3e") return "Extra Wide";
        if (compact === "4e" || compact === "eeee") return "XXWide";
        return raw;
      }

      function normalizeWidthCode(value) {
        const raw = String(value || "").trim();
        if (!raw) return "";
        const lower = raw.toLowerCase();
        if (["us", "uk", "eu", "au"].includes(lower)) return "";
        if (lower.includes("narrow")) return "B";
        if (
          lower.includes("xx") ||
          lower.includes("4e") ||
          lower.includes("eeee")
        ) {
          return "EEEE";
        }
        if (lower.includes("extra")) return "EEE";
        if (lower.includes("wide") || lower === "w") return "EE";
        if (lower === "reg" || lower === "regular" || lower === "m") {
          return "D";
        }
        const compact = lower.replace(/[^a-z0-9]/g, "");
        if (["us", "uk", "eu", "au"].includes(compact)) return "";
        if (compact === "d") return "D";
        if (compact === "b" || compact === "c") return "B";
        if (compact === "e" || compact === "ee" || compact === "2e") {
          return "EE";
        }
        if (compact === "eee" || compact === "3e") return "EEE";
        if (compact === "4e" || compact === "eeee") return "EEEE";
        return compact ? compact.toUpperCase() : "";
      }

      function getWidthLabelFromCode(code) {
        const compact = String(code || "")
          .trim()
          .toUpperCase();
        if (!compact) return "";
        if (["B", "C", "A", "AA", "AAA"].includes(compact)) return "Narrow";
        if (compact === "D" || compact === "M") return "Reg";
        if (compact === "E" || compact === "EE") return "Wide";
        if (compact === "EEE") return "Extra Wide";
        if (compact === "EEEE") return "XXWide";
        return normalizeWidthLabel(compact);
      }

      function formatWidthTag(raw) {
        const code = normalizeWidthCode(raw);
        if (!code) return "";
        const label = getWidthLabelFromCode(code);
        return label ? `${code} ${label} Width` : `${code} Width`;
      }

      function formatNumber(value, decimals) {
        const factor = 10 ** decimals;
        const rounded = Math.round(value * factor) / factor;
        const fixed = rounded.toFixed(decimals);
        return fixed.replace(/\.0+$/, "");
      }

      function roundInchesToStandardStep(value) {
        if (value === null || Number.isNaN(value)) return null;
        // Standard tape-style rounding: nearest 1/16 inch.
        return Math.round(value * 16) / 16;
      }

      function formatInches(value, verified) {
        const rounded = roundInchesToStandardStep(value);
        const text = `${formatNumber(rounded, 2)} in`;
        return verified ? text : `~${text}`;
      }

      function formatCentimeters(value, verified) {
        const roundedInches = roundInchesToStandardStep(value);
        const text = `${formatNumber(roundedInches * 2.54, 1)} cm`;
        return verified ? text : `~${text}`;
      }

      function formatKilograms(value, verified) {
        const text = `${formatNumber(value * 0.453592, 2)} kg`;
        return verified ? text : `~${text}`;
      }

      function formatWeightParts(lb, oz) {
        const parts = [];
        if (lb !== null && !Number.isNaN(lb)) {
          parts.push(`${formatNumber(lb, 0)} lb`);
        }
        if (oz !== null && !Number.isNaN(oz)) {
          const ozText = `${formatNumber(oz, 0)} oz`;
          if (!parts.length) {
            parts.push(`0 lb`);
          }
          parts.push(ozText);
        }
        return parts.join(" ");
      }

      function getWeightPartsFromInputs() {
        const lb = parseNumber(weightLbInput?.value);
        const oz = parseNumber(weightOzInput?.value);
        const hasValue = lb !== null || oz !== null;
        const totalPounds = hasValue ? (lb || 0) + (oz || 0) / 16 : null;
        return { lb, oz, totalPounds, hasValue };
      }

      function addMeasurementLine(
        label,
        inches,
        lines,
        imperial,
        metric,
        verified,
      ) {
        if (inches === null) return;
        const inText = formatInches(inches, verified);
        const cmText = formatCentimeters(inches, verified);
        lines.push(`${label}: ${inText} (${cmText})`);
        imperial.push(`${label}: ${inText}`);
        metric.push(`${label}: ${cmText}`);
      }

      function addWeightLine(
        label,
        weightParts,
        lines,
        imperial,
        metric,
        verified,
      ) {
        if (!weightParts || weightParts.totalPounds === null) return;
        const weightText = formatWeightParts(weightParts.lb, weightParts.oz);
        const lbText = verified ? weightText : `~${weightText}`;
        const kgText = formatKilograms(weightParts.totalPounds, verified);
        lines.push(`${label}: ${lbText} (${kgText})`);
        imperial.push(`${label}: ${lbText}`);
        metric.push(`${label}: ${kgText}`);
      }

      function buildSizeTagFromInputs(data, options = {}) {
        const { defaultWidthReg = false } = options;
        const raw = getRawSizeInputs();
        const values = applySizeConversions(data, raw, { writeBack: false });
        const width = String(sizeWidthInput?.value || "").trim();
        if (
          values.usMen === null &&
          values.usWomen === null &&
          values.uk === null &&
          values.eu === null
        ) {
          return "";
        }
        const intended = getIntendedForValues(data).map((item) =>
          String(item).toLowerCase(),
        );
        const isUnisex = intended.includes("unisex");
        const isWomen = intended.includes("women") && !isUnisex;
        const usMenVerified = isVerified(verifiedToggles.sizeUsMen);
        const usWomenVerified = isVerified(verifiedToggles.sizeUsWomen);
        const ukVerified = isVerified(verifiedToggles.sizeUk);
        const euVerified = isVerified(verifiedToggles.sizeEu);
        const auVerified = isVerified(verifiedToggles.sizeAu);
        const deriveUsFromValues = (offsets) => {
          if (values.uk !== null) return values.uk - offsets.usToUk;
          if (values.eu !== null) return values.eu - offsets.usToEu;
          if (values.au !== null) return values.au - offsets.usToAu;
          return null;
        };
        const menOffsets = getSizeOffsetsForUsType(data, "men");
        const womenOffsets = getSizeOffsetsForUsType(data, "women");
        let menValue = values.usMen;
        let womenValue = values.usWomen;
        let menEstimated = values.estimated?.usMen;
        let womenEstimated = values.estimated?.usWomen;
        if (isUnisex) {
          if (menValue === null) {
            const derivedMen = deriveUsFromValues(menOffsets);
            if (derivedMen !== null) {
              menValue = derivedMen;
              menEstimated = true;
            }
          }
          if (womenValue === null) {
            const derivedWomen = deriveUsFromValues(womenOffsets);
            if (derivedWomen !== null) {
              womenValue = derivedWomen;
              womenEstimated = true;
            }
          }
        } else if (isWomen) {
          if (womenValue === null) {
            const derivedWomen = deriveUsFromValues(womenOffsets);
            if (derivedWomen !== null) {
              womenValue = derivedWomen;
              womenEstimated = true;
            }
          }
          menValue = null;
        } else {
          if (menValue === null) {
            const derivedMen = deriveUsFromValues(menOffsets);
            if (derivedMen !== null) {
              menValue = derivedMen;
              menEstimated = true;
            }
          }
          womenValue = null;
        }
        const usMenText = formatSizeValue(
          menValue,
          menEstimated,
          usMenVerified,
        );
        const usWomenText = formatSizeValue(
          womenValue,
          womenEstimated,
          usWomenVerified,
        );
        const ukText = formatSizeValue(
          values.uk,
          values.estimated?.uk,
          ukVerified,
        );
        const euText = formatSizeValue(
          values.eu,
          values.estimated?.eu,
          euVerified,
        );
        const auText = formatSizeValue(
          values.au,
          values.estimated?.au,
          auVerified,
        );
        const parts = [];
        if (isUnisex) {
          if (usMenText !== null && isIncluded(includeToggles.sizeUsMen)) {
            parts.push(`US M ${usMenText}`);
          }
          if (usWomenText !== null && isIncluded(includeToggles.sizeUsWomen)) {
            parts.push(`US W ${usWomenText}`);
          }
        } else {
          if (isWomen) {
            if (
              usWomenText !== null &&
              isIncluded(includeToggles.sizeUsWomen)
            ) {
              parts.push(`US W ${usWomenText}`);
            }
          } else if (
            usMenText !== null &&
            isIncluded(includeToggles.sizeUsMen)
          ) {
            parts.push(`US M ${usMenText}`);
          }
        }
        if (ukText !== null && isIncluded(includeToggles.sizeUk)) {
          parts.push(`UK ${ukText}`);
        }
        if (euText !== null && isIncluded(includeToggles.sizeEu)) {
          parts.push(`EU ${euText}`);
        }
        if (auText !== null && isIncluded(includeToggles.sizeAu)) {
          parts.push(`AU ${auText}`);
        }
        let widthText = formatWidthTag(width);
        if (!widthText && defaultWidthReg) {
          widthText = "Reg Width";
        }
        if (widthText && isIncluded(includeToggles.sizeWidth)) {
          parts.push(widthText);
        }
        return parts.join(" / ");
      }

      function inferBaseSizeFromText(text, data) {
        const input = String(text || "");
        const usMenMatch = input.match(/US\s*M\s*([0-9.]+)/i);
        const usWomenMatch = input.match(/US\s*W\s*([0-9.]+)/i);
        const usMatch = input.match(/US\s*([0-9.]+)/i);
        const ukMatch = input.match(/UK\s*([0-9.]+)/i);
        const euMatch = input.match(/EU\s*([0-9.]+)/i);
        const auMatch = input.match(/AU\s*([0-9.]+)/i);
        const entries = [
          usMenMatch ? ["us_m", usMenMatch[1]] : null,
          usWomenMatch ? ["us_w", usWomenMatch[1]] : null,
          usMatch ? ["us_m", usMatch[1]] : null,
          ukMatch ? ["uk", ukMatch[1]] : null,
          euMatch ? ["eu", euMatch[1]] : null,
          auMatch ? ["au", auMatch[1]] : null,
        ].filter(Boolean);
        const unique = [];
        entries.forEach(([key, value]) => {
          if (unique.find((item) => item.key === key)) return;
          unique.push({ key, value });
        });
        const preferredKey =
          getPreferredUsType(data || currentData) === "women" ? "us_w" : "us_m";
        const preferred =
          unique.find((item) => item.key === preferredKey) ||
          unique.find((item) => item.key === "us_m") ||
          unique.find((item) => item.key === "us_w");
        if (preferred) return preferred;
        if (unique.length === 1) return unique[0];
        const plainMatch = input.match(/^\s*([0-9]+(?:\.[0-9]+)?)/);
        if (plainMatch) {
          const usType = getPreferredUsType(data || currentData);
          return {
            key: usType === "women" ? "us_w" : "us_m",
            value: plainMatch[1],
          };
        }
        return null;
      }

      function normalizeSizeInputsFromBase(data) {
        const base = inferBaseSizeFromText(data?.size_or_fit, data);
        if (!base) return;
        const value = parseNumber(base.value);
        if (value === null) return;
        if (base.key === "us_m") {
          sizeUsMenInput.value = value;
          updateIncludeToggleForInput(sizeUsMenInput);
        } else if (base.key === "us_w") {
          sizeUsWomenInput.value = value;
          updateIncludeToggleForInput(sizeUsWomenInput);
        } else if (base.key === "uk") {
          sizeUkInput.value = value;
          updateIncludeToggleForInput(sizeUkInput);
        } else if (base.key === "eu") {
          sizeEuInput.value = value;
          updateIncludeToggleForInput(sizeEuInput);
        } else if (base.key === "au") {
          sizeAuInput.value = value;
          updateIncludeToggleForInput(sizeAuInput);
        }
        lastSizeEdited = base.key;
        if (currentData) {
          currentData.last_size_edited = base.key;
        }
      }

      function syncSizeInputsFromSizeOrFit(data) {
        if (!data) return;
        const sizeText = String(data.size_or_fit || "").trim();
        const clearInputs = [
          sizeUsMenInput,
          sizeUsWomenInput,
          sizeUkInput,
          sizeEuInput,
          sizeAuInput,
          sizeWidthInput,
        ];
        clearInputs.forEach((input) => {
          if (!input) return;
          input.value = "";
          updateIncludeToggleForInput(input);
        });
        const usedOriginal = applyOriginalSizeReference(data);
        if (usedOriginal) {
          applySizeConversions(data, getRawSizeInputs());
          return;
        }
        originalSizeRef = null;
        if (!sizeText) return;
        const base = inferBaseSizeFromText(sizeText, data);
        if (base) {
          const value = parseNumber(base.value);
          if (value !== null) {
            if (base.key === "us_m") {
              sizeUsMenInput.value = value;
              lastSizeEdited = "us_m";
            } else if (base.key === "us_w") {
              sizeUsWomenInput.value = value;
              lastSizeEdited = "us_w";
            } else if (base.key === "uk") {
              sizeUkInput.value = value;
              lastSizeEdited = "uk";
            } else if (base.key === "eu") {
              sizeEuInput.value = value;
              lastSizeEdited = "eu";
            } else if (base.key === "au") {
              sizeAuInput.value = value;
              lastSizeEdited = "au";
            }
            if (data) data.last_size_edited = lastSizeEdited;
          }
        }
        const widthMatch = sizeText.match(/Width\s*([A-Za-z0-9]+)/i);
        let widthValue = widthMatch ? widthMatch[1] : "";
        if (!widthValue) {
          const trailingWidthMatch = sizeText.match(
            /[0-9]+(?:\.[0-9]+)?\s*([A-Za-z]{1,4}|[0-9]E)\b/i,
          );
          widthValue = trailingWidthMatch ? trailingWidthMatch[1] : "";
        }
        const widthCode = normalizeWidthCode(widthValue);
        if (widthCode) {
          sizeWidthInput.value = widthCode;
        }
        clearInputs.forEach((input) => {
          if (!input) return;
          updateIncludeToggleForInput(input);
        });
        applySizeConversions(data, getRawSizeInputs());
      }

      function buildSizeOrFitValue(data) {
        const raw = getRawSizeInputs();
        const originalRef = getOriginalSizeReference(data);
        const originalKeyMap = {
          us_m: "usMen",
          us_w: "usWomen",
          uk: "uk",
          eu: "eu",
          au: "au",
        };
        let source = resolveSizeBase(raw, lastSizeEdited, data);
        // Keep size_or_fit anchored to original_size when available,
        // so editing converted sizes (UK/EU/AU) does not replace the
        // original US base in saved data.
        if (originalRef) {
          const originalRawKey = originalKeyMap[originalRef.key];
          if (originalRawKey && raw[originalRawKey] !== null) {
            source = originalRef.key;
          }
        }
        if (!source) return "";
        let value = null;
        if (source === "us_m") {
          value = raw.usMen;
        } else if (source === "us_w") {
          value = raw.usWomen;
        } else if (source === "uk") {
          value = raw.uk;
        } else if (source === "eu") {
          value = raw.eu;
        } else if (source === "au") {
          value = raw.au;
        }
        if (value === null) return "";
        const sizeText = formatNumber(value, 1);
        const widthCode = normalizeWidthCode(sizeWidthInput?.value);
        return widthCode ? `${sizeText} ${widthCode}` : sizeText;
      }

      function updateSizeOrFitFromHelper(data, options = {}) {
        const { force = false } = options;
        if (!data) return;
        const next = buildSizeOrFitValue(data);
        const current = String(data.size_or_fit || "").trim();
        const hasPlaceholder = current.includes("__");
        const needsNormalize =
          /\b(US|UK|EU|AU)\b/i.test(current) ||
          /Width/i.test(current) ||
          current.includes("/");
        if (!next) {
          if (hasPlaceholder) {
            data.size_or_fit = "";
            lastAutoSize = "";
            const input = fieldInputMap.size_or_fit;
            if (input && input.value) {
              input.value = "";
            }
          }
          return;
        }
        if (
          !force &&
          current &&
          current !== lastAutoSize &&
          !hasPlaceholder &&
          !needsNormalize
        ) {
          return;
        }
        data.size_or_fit = next;
        lastAutoSize = next;
        const input = fieldInputMap.size_or_fit;
        if (input && input.value !== next) {
          input.value = next;
        }
      }

      function setFieldValue(key, value) {
        if (!currentData) return;
        currentData[key] = value;
        const input = fieldInputMap[key];
        if (!input) return;
        if (Array.isArray(value)) {
          input.value = value.join("\n");
        } else {
          input.value = value ?? "";
        }
        updateCharCounter(key);
      }

      function hasMeasurementInputs(values) {
        return Object.values(values).some((value) => value !== null);
      }

      function detectMeasurementTemplate(data) {
        const lines = Array.isArray(data?.measurements)
          ? data.measurements.join("\n").toLowerCase()
          : String(data?.measurements || "").toLowerCase();
        if (lines.includes("outsole") || lines.includes("insole")) {
          if (
            lines.includes("shaft") ||
            lines.includes("calf") ||
            lines.includes("opening")
          ) {
            return "boot";
          }
          return "shoe";
        }
        if (
          lines.includes("chest") ||
          lines.includes("waist") ||
          lines.includes("inseam") ||
          lines.includes("sleeve")
        ) {
          return "garment";
        }
        if (
          lines.includes("length") &&
          lines.includes("width") &&
          lines.includes("height")
        ) {
          return "standard";
        }
        return "shoe";
      }

      function getSelectedTemplate() {
        if (!measurementTemplateSelect) return "shoe";
        if (measurementTemplateSelect.value !== "auto") {
          return measurementTemplateSelect.value;
        }
        return detectMeasurementTemplate(currentData);
      }

      function updateMeasurementsFromHelper(options = {}) {
        if (!currentData) return;
        if (!options.skipSizeNormalize) {
          normalizeSizeInputsFromBase(currentData);
        }
        const template = getSelectedTemplate();
        const values = {
          outsoleLength: parseNumber(outsoleLengthInput?.value),
          outsoleWidth: parseNumber(outsoleWidthInput?.value),
          insoleLength: parseNumber(insoleLengthInput?.value),
          insoleWidth: parseNumber(insoleWidthInput?.value),
          heelHeight: parseNumber(heelHeightInput?.value),
          platformHeight: parseNumber(platformHeightInput?.value),
          toeBoxHeight: parseNumber(toeBoxHeightInput?.value),
          shaftHeight: parseNumber(shaftHeightInput?.value),
          shaftCirc: parseNumber(shaftCircInput?.value),
          calfCirc: parseNumber(calfCircInput?.value),
          weightParts: getWeightPartsFromInputs(),
          garmentChest: parseNumber(garmentChestInput?.value),
          garmentLength: parseNumber(garmentLengthInput?.value),
          garmentShoulder: parseNumber(garmentShoulderInput?.value),
          garmentSleeve: parseNumber(garmentSleeveInput?.value),
          garmentWaist: parseNumber(garmentWaistInput?.value),
          garmentInseam: parseNumber(garmentInseamInput?.value),
          garmentRise: parseNumber(garmentRiseInput?.value),
          garmentHip: parseNumber(garmentHipInput?.value),
          standardLength: parseNumber(standardLengthInput?.value),
          standardWidth: parseNumber(standardWidthInput?.value),
          standardHeight: parseNumber(standardHeightInput?.value),
        };

        const sizeTag = buildSizeTagFromInputs(currentData, {
          defaultWidthReg: true,
        });
        const hasMeasurements = hasMeasurementInputs(values);
        if (!hasMeasurements && !sizeTag) {
          return;
        }

        const lines = [];
        const imperial = [];
        const metric = [];
        const isMeasurementVerified = (key) => isVerified(verifiedToggles[key]);

        if (sizeTag) {
          lines.push(`Size / Fit: ${sizeTag}`);
        }

        if (template === "shoe" || template === "boot") {
          if (isIncluded(includeToggles.outsoleLength)) {
            addMeasurementLine(
              "Outsole length (heel-to-toe)",
              values.outsoleLength,
              lines,
              imperial,
              metric,
              isMeasurementVerified("outsoleLength"),
            );
          }
          if (isIncluded(includeToggles.outsoleWidth)) {
            addMeasurementLine(
              "Outsole width (widest)",
              values.outsoleWidth,
              lines,
              imperial,
              metric,
              isMeasurementVerified("outsoleWidth"),
            );
          }
          if (isIncluded(includeToggles.insoleLength)) {
            addMeasurementLine(
              "Insole length (heel to toe)",
              values.insoleLength,
              lines,
              imperial,
              metric,
              isMeasurementVerified("insoleLength"),
            );
          }
          if (isIncluded(includeToggles.insoleWidth)) {
            addMeasurementLine(
              "Insole width (ball area)",
              values.insoleWidth,
              lines,
              imperial,
              metric,
              isMeasurementVerified("insoleWidth"),
            );
          }
          if (isIncluded(includeToggles.heelHeight)) {
            addMeasurementLine(
              "Heel height",
              values.heelHeight,
              lines,
              imperial,
              metric,
              isMeasurementVerified("heelHeight"),
            );
          }
          if (isIncluded(includeToggles.platformHeight)) {
            addMeasurementLine(
              "Platform height (forefoot)",
              values.platformHeight,
              lines,
              imperial,
              metric,
              isMeasurementVerified("platformHeight"),
            );
          }
          if (isIncluded(includeToggles.toeBoxHeight)) {
            addMeasurementLine(
              "Toe box height",
              values.toeBoxHeight,
              lines,
              imperial,
              metric,
              isMeasurementVerified("toeBoxHeight"),
            );
          }

          if (template === "boot") {
            if (isIncluded(includeToggles.shaftHeight)) {
              addMeasurementLine(
                "Shaft height (from outsole)",
                values.shaftHeight,
                lines,
                imperial,
                metric,
                isMeasurementVerified("shaftHeight"),
              );
            }
            if (isIncluded(includeToggles.shaftCirc)) {
              addMeasurementLine(
                "Shaft opening (circumference)",
                values.shaftCirc,
                lines,
                imperial,
                metric,
                isMeasurementVerified("shaftCirc"),
              );
            }
            if (isIncluded(includeToggles.calfCirc)) {
              addMeasurementLine(
                "Calf circumference (widest point)",
                values.calfCirc,
                lines,
                imperial,
                metric,
                isMeasurementVerified("calfCirc"),
              );
            }
          }

          if (
            values.weightParts?.hasValue &&
            isIncluded(includeToggles.weight)
          ) {
            const weightLabel =
              weightPerSelect?.value === "boot"
                ? "Weight (per boot)"
                : "Weight (pair)";
            addWeightLine(
              weightLabel,
              values.weightParts,
              lines,
              imperial,
              metric,
              isMeasurementVerified("weight"),
            );
          }
        }

        if (template === "garment") {
          if (isIncluded(includeToggles.garmentChest)) {
            addMeasurementLine(
              "Chest (pit to pit)",
              values.garmentChest,
              lines,
              imperial,
              metric,
              isMeasurementVerified("garmentChest"),
            );
          }
          if (isIncluded(includeToggles.garmentLength)) {
            addMeasurementLine(
              "Length (shoulder to hem)",
              values.garmentLength,
              lines,
              imperial,
              metric,
              isMeasurementVerified("garmentLength"),
            );
          }
          if (isIncluded(includeToggles.garmentShoulder)) {
            addMeasurementLine(
              "Shoulder width",
              values.garmentShoulder,
              lines,
              imperial,
              metric,
              isMeasurementVerified("garmentShoulder"),
            );
          }
          if (isIncluded(includeToggles.garmentSleeve)) {
            addMeasurementLine(
              "Sleeve length",
              values.garmentSleeve,
              lines,
              imperial,
              metric,
              isMeasurementVerified("garmentSleeve"),
            );
          }
          if (isIncluded(includeToggles.garmentWaist)) {
            addMeasurementLine(
              "Waist",
              values.garmentWaist,
              lines,
              imperial,
              metric,
              isMeasurementVerified("garmentWaist"),
            );
          }
          if (isIncluded(includeToggles.garmentInseam)) {
            addMeasurementLine(
              "Inseam",
              values.garmentInseam,
              lines,
              imperial,
              metric,
              isMeasurementVerified("garmentInseam"),
            );
          }
          if (isIncluded(includeToggles.garmentRise)) {
            addMeasurementLine(
              "Rise",
              values.garmentRise,
              lines,
              imperial,
              metric,
              isMeasurementVerified("garmentRise"),
            );
          }
          if (isIncluded(includeToggles.garmentHip)) {
            addMeasurementLine(
              "Hip",
              values.garmentHip,
              lines,
              imperial,
              metric,
              isMeasurementVerified("garmentHip"),
            );
          }
        }

        if (template === "standard") {
          if (isIncluded(includeToggles.standardLength)) {
            addMeasurementLine(
              "Length",
              values.standardLength,
              lines,
              imperial,
              metric,
              isMeasurementVerified("standardLength"),
            );
          }
          if (isIncluded(includeToggles.standardWidth)) {
            addMeasurementLine(
              "Width",
              values.standardWidth,
              lines,
              imperial,
              metric,
              isMeasurementVerified("standardWidth"),
            );
          }
          if (isIncluded(includeToggles.standardHeight)) {
            addMeasurementLine(
              "Height",
              values.standardHeight,
              lines,
              imperial,
              metric,
              isMeasurementVerified("standardHeight"),
            );
          }
        }

        setFieldValue("measurements", lines);
        setFieldValue("measurements_imperial", imperial);
        setFieldValue("measurements_metric", metric);
        currentData.last_size_edited = lastSizeEdited || "";
        updateListperfectlyDescription(currentData);
        saveSession();
      }

      function toggleMeasurementFields() {
        if (!measurementTemplateSelect) return;
        const template =
          measurementTemplateSelect.value === "auto"
            ? detectMeasurementTemplate(currentData)
            : measurementTemplateSelect.value;
        if (shoeFields) {
          shoeFields.style.display =
            template === "shoe" || template === "boot" ? "flex" : "none";
        }
        if (bootFields) {
          bootFields.style.display = template === "boot" ? "flex" : "none";
        }
        if (garmentFields) {
          garmentFields.style.display =
            template === "garment" ? "flex" : "none";
        }
        if (standardFields) {
          standardFields.style.display =
            template === "standard" ? "flex" : "none";
        }
      }

      function extractInches(line) {
        const match = String(line || "").match(/:\s*~?([^()]+?)\s*in\b/i);
        if (!match) return null;
        const token = String(match[1] || "").trim();
        const decimal = Number.parseFloat(token);
        if (Number.isFinite(decimal)) return decimal;
        const mixed = token.match(/^(\d+)\s+(\d+)\/(\d+)$/);
        if (mixed) {
          const whole = Number.parseFloat(mixed[1]);
          const num = Number.parseFloat(mixed[2]);
          const den = Number.parseFloat(mixed[3]);
          if (den) return whole + num / den;
        }
        const frac = token.match(/^(\d+)\/(\d+)$/);
        if (frac) {
          const num = Number.parseFloat(frac[1]);
          const den = Number.parseFloat(frac[2]);
          if (den) return num / den;
        }
        return null;
      }

      function extractWeightParts(line) {
        const text = String(line || "");
        const lbMatch = text.match(/:\s*~?([\d.]+)\s*lb\b/i);
        const ozMatch = text.match(/([\d.]+)\s*oz\b/i);
        const lb = lbMatch ? Number.parseFloat(lbMatch[1]) : null;
        const oz = ozMatch ? Number.parseFloat(ozMatch[1]) : null;
        if (lb === null && oz === null) return null;
        return { lb, oz };
      }

      function setInputValue(input, value) {
        if (!input || value === null || Number.isNaN(value)) return;
        if (String(input.value || "").trim()) return;
        input.value = value;
      }

      function populateMeasurementHelperFromData(data) {
        if (!data) return;
        const lines = Array.isArray(data.measurements)
          ? data.measurements
          : parseList(data.measurements);
        if (!lines.length) return;

        const lineMap = new Map();
        lines.forEach((line) => {
          const [label] = String(line).split(":");
          if (!label) return;
          lineMap.set(label.trim().toLowerCase(), line);
        });

        const setFromLabel = (label, input, parser) => {
          const line = lineMap.get(label.toLowerCase());
          if (!line) return;
          const value = parser(line);
          setInputValue(input, value);
        };

        setFromLabel(
          "Outsole length (heel-to-toe)",
          outsoleLengthInput,
          extractInches,
        );
        setFromLabel(
          "Outsole width (widest)",
          outsoleWidthInput,
          extractInches,
        );
        setFromLabel(
          "Insole length (heel to toe)",
          insoleLengthInput,
          extractInches,
        );
        setFromLabel(
          "Insole width (ball area)",
          insoleWidthInput,
          extractInches,
        );
        setFromLabel("Heel height", heelHeightInput, extractInches);
        setFromLabel(
          "Platform height (forefoot)",
          platformHeightInput,
          extractInches,
        );
        setFromLabel("Toe box height", toeBoxHeightInput, extractInches);
        setFromLabel(
          "Shaft height (from outsole)",
          shaftHeightInput,
          extractInches,
        );
        setFromLabel(
          "Shaft opening (circumference)",
          shaftCircInput,
          extractInches,
        );
        setFromLabel(
          "Calf circumference (widest point)",
          calfCircInput,
          extractInches,
        );
        setFromLabel("Chest (pit to pit)", garmentChestInput, extractInches);
        setFromLabel(
          "Length (shoulder to hem)",
          garmentLengthInput,
          extractInches,
        );
        setFromLabel("Shoulder width", garmentShoulderInput, extractInches);
        setFromLabel("Sleeve length", garmentSleeveInput, extractInches);
        setFromLabel("Waist", garmentWaistInput, extractInches);
        setFromLabel("Inseam", garmentInseamInput, extractInches);
        setFromLabel("Rise", garmentRiseInput, extractInches);
        setFromLabel("Hip", garmentHipInput, extractInches);
        setFromLabel("Length", standardLengthInput, extractInches);
        setFromLabel("Width", standardWidthInput, extractInches);
        setFromLabel("Height", standardHeightInput, extractInches);

        lines.forEach((line) => {
          if (!line.toLowerCase().includes("weight")) return;
          const parts = extractWeightParts(line);
          if (!parts) return;
          if (parts.lb !== null) setInputValue(weightLbInput, parts.lb);
          if (parts.oz !== null) setInputValue(weightOzInput, parts.oz);
          if (weightPerSelect) {
            if (line.toLowerCase().includes("per boot")) {
              weightPerSelect.value = "boot";
            } else {
              weightPerSelect.value = "pair";
            }
          }
        });

        const usedOriginal = applyOriginalSizeReference(data, {
          preserveExisting: true,
        });
        if (usedOriginal) {
          const raw = getRawSizeInputs();
          const source = resolveSizeBase(raw, lastSizeEdited, data);
          if (shouldAutofillConvertedSizes(raw, source)) {
            applySizeConversions(data, raw, { writeBack: true });
          } else {
            syncSizeVerifiedDefaults(convertSizeValues(raw, data, lastSizeEdited));
          }
          updateSizeOrFitFromHelper(data);
          return;
        }
        originalSizeRef = null;
        const sizeText = String(data.size_or_fit || "");
        if (sizeText) {
          const usMenMatch = sizeText.match(/US\s*M\s*([0-9.]+)/i);
          const usWomenMatch = sizeText.match(/US\s*W\s*([0-9.]+)/i);
          const usMatch = sizeText.match(/US\s*([0-9.]+)/i);
          const ukMatch = sizeText.match(/UK\s*([0-9.]+)/i);
          const euMatch = sizeText.match(/EU\s*([0-9.]+)/i);
          const auMatch = sizeText.match(/AU\s*([0-9.]+)/i);
          const widthMatch = sizeText.match(/Width\s*([A-Za-z0-9]+)/i);
          if (usMenMatch) setInputValue(sizeUsMenInput, usMenMatch[1]);
          else if (usMatch) setInputValue(sizeUsMenInput, usMatch[1]);
          if (usWomenMatch) setInputValue(sizeUsWomenInput, usWomenMatch[1]);
          if (ukMatch) setInputValue(sizeUkInput, ukMatch[1]);
          if (euMatch) setInputValue(sizeEuInput, euMatch[1]);
          if (auMatch) setInputValue(sizeAuInput, auMatch[1]);
          if (
            !usMenMatch &&
            !usWomenMatch &&
            !usMatch &&
            !ukMatch &&
            !euMatch &&
            !auMatch
          ) {
            const plainMatch = sizeText.match(/^\s*([0-9]+(?:\.[0-9]+)?)/);
            if (plainMatch) {
              const preferred = getPreferredUsType(data);
              if (preferred === "women") {
                setInputValue(sizeUsWomenInput, plainMatch[1]);
              } else {
                setInputValue(sizeUsMenInput, plainMatch[1]);
              }
            }
          }
          let widthValue = widthMatch ? widthMatch[1] : "";
          if (!widthValue) {
            const trailingWidthMatch = sizeText.match(
              /[0-9]+(?:\.[0-9]+)?\s*([A-Za-z]{1,4}|[0-9]E)\b/i,
            );
            widthValue = trailingWidthMatch ? trailingWidthMatch[1] : "";
          }
          const widthCode = normalizeWidthCode(widthValue);
          if (widthCode) setInputValue(sizeWidthInput, widthCode);
        }
        {
          const raw = getRawSizeInputs();
          const source = resolveSizeBase(raw, lastSizeEdited, data);
          if (shouldAutofillConvertedSizes(raw, source)) {
            applySizeConversions(data, raw, { writeBack: true });
          } else {
            syncSizeVerifiedDefaults(convertSizeValues(raw, data, lastSizeEdited));
          }
        }
        updateSizeOrFitFromHelper(data);
      }

      function sanitizePart(value) {
        return value
          .toLowerCase()
          .replace(/['",]/g, "")
          .replace(/\s+/g, "-")
          .replace(/-+/g, "-")
          .replace(/^-|-$/g, "");
      }

      function buildFilename(data) {
        const sku = data?.sku ? sanitizePart(String(data.sku)) : "";
        const title = data?.title
          ? sanitizePart(String(data.title))
          : "listing";
        const now = new Date();
        const yyyy = String(now.getFullYear());
        const mm = String(now.getMonth() + 1).padStart(2, "0");
        const dd = String(now.getDate()).padStart(2, "0");
        const hh = String(now.getHours()).padStart(2, "0");
        const min = String(now.getMinutes()).padStart(2, "0");
        const stamp = `${yyyy}${mm}${dd}-${hh}${min}`;
        const base = sku ? `${sku}_${title}` : title;
        return `${base}_${stamp}.json`;
      }

      function getLastSku() {
        return window.localStorage.getItem("moola_last_sku") || "";
      }

      function setLastSku(value) {
        if (value) {
          window.localStorage.setItem("moola_last_sku", value);
        }
      }

      function saveSession() {
        if (!currentData) return;
        try {
          window.localStorage.setItem(
            sessionStorageKey,
            JSON.stringify(currentData),
          );
        } catch (err) {
          // Ignore storage errors.
        }
      }

      function clearSession() {
        window.localStorage.removeItem(sessionStorageKey);
      }

      function resetToEmpty() {
        items = [];
        currentIndex = 0;
        currentData = null;
        skuConfirmed = false;
        fieldInputs = [];
        fieldInputMap = {};
        lpPanel.style.display = "none";
        measurementsHelperPanel.style.display = "none";
        shippingPanel.style.display = "none";
        corePanel.style.display = "none";
        platformPanel.style.display = "none";
        additionalPanel.style.display = "none";
        skuPanel.style.display = "none";
        lpFieldsContainer.innerHTML = "";
        if (lpCoreFieldsContainer) {
          lpCoreFieldsContainer.innerHTML = "";
        }
        if (measurementSummaryFieldsContainer) {
          measurementSummaryFieldsContainer.innerHTML = "";
        }
        if (shippingFieldsContainer) {
          shippingFieldsContainer.innerHTML = "";
        }
        ebayPlatformFieldsContainer.innerHTML = "";
        depopPlatformFieldsContainer.innerHTML = "";
        typesMiscFieldsContainer.innerHTML = "";
        additionalFieldsContainer.innerHTML = "";
        downloadBtn.disabled = true;
        if (previewBtn) previewBtn.disabled = true;
        if (mergeBtn) mergeBtn.disabled = true;
        if (terapeakBtn) terapeakBtn.disabled = true;
        prevBtn.disabled = true;
        nextBtn.disabled = true;
        if (fileInput) fileInput.value = "";
        updateStatus();
      }

      function resetMeasurementHelper() {
        lastAutoSize = "";
        originalSizeRef = null;
        lastSizeEdited = currentData?.last_size_edited || null;
        if (lastSizeEdited === "us") lastSizeEdited = "us_m";
        includeDefaultsApplied = false;
        if (measurementTemplateSelect) {
          measurementTemplateSelect.value = "auto";
        }
        if (weightPerSelect) {
          weightPerSelect.value = "pair";
        }
        if (Array.isArray(measurementInputs)) {
          measurementInputs.forEach((input) => {
            if (!input) return;
            input.value = "";
          });
        }
        measurementTogglePairs.forEach(({ includeToggle, verifiedToggle }) => {
          if (includeToggle) {
            includeToggle.checked = false;
            includeToggle.dataset.manual = "false";
          }
          if (verifiedToggle) {
            verifiedToggle.checked = false;
            verifiedToggle.dataset.manual = "false";
          }
        });
      }

      function clearOtherSizeInputs(sourceInput) {
        const usInputs = [sizeUsMenInput, sizeUsWomenInput];
        const sizeInputs = [
          sizeUsMenInput,
          sizeUsWomenInput,
          sizeUkInput,
          sizeEuInput,
          sizeAuInput,
        ];
        sizeInputs.forEach((input) => {
          if (!input || input === sourceInput) return;
          if (usInputs.includes(sourceInput) && usInputs.includes(input)) {
            return;
          }
          input.value = "";
        });
      }

      function setDefaultPanelStateWhenLoaded() {
        const panelsToClose = [
          skuPanel,
          lpPanel,
          measurementsHelperPanel,
          shippingPanel,
          corePanel,
          platformPanel,
          additionalPanel,
        ].filter(Boolean);
        panelsToClose.forEach((panel) => {
          panel.open = false;
        });
        const loaderPanel = document.getElementById("loaderPanel");
        if (loaderPanel) loaderPanel.open = true;
        if (skuPanel) skuPanel.open = true;
        if (lpPanel) lpPanel.open = true;
      }

      function loadSession() {
        const raw = window.localStorage.getItem(sessionStorageKey);
        if (!raw) return false;
        try {
          const data = JSON.parse(raw);
          items = [
            {
              name: "Recovered session",
              data,
              skuConfirmed: Boolean(data?.sku),
            },
          ];
          currentIndex = 0;
          skuPanel.style.display = "block";
          loadCurrent();
          setDefaultPanelStateWhenLoaded();
          return true;
        } catch (err) {
          return false;
        }
      }

      function escapeHtml(value) {
        return String(value || "")
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/"/g, "&quot;")
          .replace(/'/g, "&#39;");
      }

      function toLines(value) {
        if (!value) return [];
        if (Array.isArray(value)) {
          return value.map((item) => String(item).trim()).filter(Boolean);
        }
        return String(value)
          .split(/\n/)
          .map((line) => line.trim())
          .filter(Boolean);
      }

      function buildPreviewHtml(data) {
        const title = String(data?.title || "Listing Preview").trim();
        const sections = [];

        const readPreviewValue = (key) => {
          const input = fieldInputMap?.[key];
          if (input) return input.value;
          return data ? data[key] : "";
        };

        const addSection = (label, content) => {
          const lines = toLines(content);
          if (!lines.length) return;
          sections.push({
            label,
            html: `<pre>${escapeHtml(lines.join("\n"))}</pre>`,
          });
        };

        const formatPlatformsPreview = (value) => {
          if (Array.isArray(value)) {
            return value
              .map((item) => {
                const platform = String(item?.platform || "").trim();
                const reason = String(item?.reason || "").trim();
                return platform && reason
                  ? `${platform}: ${reason}`
                  : platform || reason;
              })
              .filter(Boolean);
          }
          return toLines(value);
        };

        const buildPlatformsPreviewBlock = () => {
          const rawPlatforms = readPreviewValue("platforms");
          const platforms = Array.isArray(rawPlatforms)
            ? rawPlatforms
            : parsePlatforms(rawPlatforms);
          const typesParts = getTypesParts({
            types_block: readPreviewValue("types_block"),
          });
          const lines = [];
          platforms.forEach((item) => {
            const platform = String(item?.platform || "").trim();
            const reason = String(item?.reason || "").trim();
            if (!platform && !reason) return;
            lines.push(platform || "Platform");
            if (reason) lines.push(`- Reason: ${reason}`);
            const lower = platform.toLowerCase();
            if (lower === "ebay" && typesParts.ebay) {
              lines.push(`- Types: ${typesParts.ebay}`);
            }
            if (lower === "depop" && typesParts.depop) {
              lines.push(`- Types: ${typesParts.depop}`);
            }
            if (lower === "depop" && typesParts.occasions) {
              lines.push(`- Occasions: ${typesParts.occasions}`);
            }
            if (lower === "depop" && typesParts.styles) {
              lines.push(`- Styles: ${typesParts.styles}`);
            }
            lines.push("");
          });
          while (lines.length && lines[lines.length - 1] === "") {
            lines.pop();
          }
          return lines;
        };

        addSection("Hook", readPreviewValue("hook"));
        addSection("Description", readPreviewValue("description"));
        addSection("Included Items", readPreviewValue("included_items"));
        addSection("Material", readPreviewValue("material"));
        addSection("Country of Origin", readPreviewValue("country_of_origin"));
        const previewMeasurements = toLines(readPreviewValue("measurements"));
        const sizeTag = buildSizeTagFromInputs(currentData, {
          defaultWidthReg: true,
        });
        if (sizeTag) {
          const sizeLine = `Size / Fit: ${sizeTag}`;
          const sizeIdx = previewMeasurements.findIndex((line) =>
            /^size\s*\/\s*fit:/i.test(line),
          );
          if (sizeIdx >= 0) {
            previewMeasurements[sizeIdx] = sizeLine;
          } else {
            previewMeasurements.unshift(sizeLine);
          }
        }
        addSection("Measurements", previewMeasurements);
        const tagsLine = readPreviewValue("tags_line");
        const styleTags = readPreviewValue("style_tags");
        const tagsSection = [];
        if (tagsLine) tagsSection.push(`Tags: ${tagsLine}`);
        if (styleTags) tagsSection.push(`Style tags: ${styleTags}`);
        addSection("Tags / Keywords", tagsSection);
        addSection("Condition", [
          `Condition status: ${readPreviewValue("condition_status")}`,
          `Pre-Owned condition: ${readPreviewValue("pre_owned_condition")}`,
          readPreviewValue("condition"),
        ]);
        addSection("Pricing", readPreviewValue("pricing_sentence"));
        const maxProfitTime = readPreviewValue("max_profit_time_to_sell");
        const minProfitTime = readPreviewValue("min_profit_time_to_sell");
        const profitLines = [
          `Max profit price: ${readPreviewValue("max_profit_price")}`,
          `Max profit estimate: ${readPreviewValue("max_profit_estimate")}`,
          `Max profit time to sell: ${maxProfitTime}`,
          `Min profit price: ${readPreviewValue("min_profit_price")}`,
          `Min profit estimate: ${readPreviewValue("min_profit_estimate")}`,
          `Min profit time to sell: ${minProfitTime}`,
        ];
        const offerRecommendation = readPreviewValue("offer_recommendation");
        if (offerRecommendation) {
          profitLines.push(offerRecommendation);
        }
        if (!maxProfitTime && !minProfitTime) {
          profitLines.push(
            `Time To Sell: ${readPreviewValue("time_to_sell_sentence")}`,
          );
        }
        addSection("Profit Estimates", profitLines);
        addSection(
          "Shipping Estimate",
          readPreviewValue("shipping_estimate_sentence"),
        );
        addSection("Fees Breakdown", [
          `Platform fees: ${readPreviewValue("platform_fee_estimate")}`,
          `Payment processing: ${readPreviewValue(
            "payment_processing_fee_estimate",
          )}`,
          `Labor: ${readPreviewValue("labor_cost_estimate")}`,
          `Fees or Other Costs: ${readPreviewValue("fees_or_other_costs")}`,
        ]);

        addSection("Platforms", buildPlatformsPreviewBlock());
        const miscTypes = [];
        const typesParts = getTypesParts({
          types_block: readPreviewValue("types_block"),
        });
        if (typesParts.misc?.length) {
          miscTypes.push(...typesParts.misc);
        }
        addSection("Misc", miscTypes);
        addSection("Seller Notes", readPreviewValue("notes"));

        const sectionsHtml = sections
          .map(
            (section) => `
          <section>
            <h2>${escapeHtml(section.label)}</h2>
            ${section.html}
          </section>`,
          )
          .join("");

        return `<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>${escapeHtml(title || "Listing Preview")}</title>
    <style>
      :root {
        color-scheme: dark;
      }
      body {
        font-family: "Inter", "Segoe UI", Tahoma, Arial, sans-serif;
        margin: 24px;
        color: #f4edff;
        background: radial-gradient(circle at top, #2a104a 0%, #0f081b 55%, #0b0614 100%);
        font-size: 16px;
        line-height: 1.7;
        letter-spacing: 0;
      }
      h1 {
        margin-bottom: 12px;
        font-size: 28px;
        color: #f7e9ff;
      }
      h2 {
        margin: 0 0 10px;
        font-size: 17px;
        color: #d7c3ff;
      }
      section {
        margin-bottom: 14px;
        padding-bottom: 12px;
        border-bottom: 1px solid #2b1a44;
      }
      section:last-of-type {
        border-bottom: none;
      }
      pre {
        white-space: pre-wrap;
        margin: 0;
        color: #f2eaff;
        background: transparent;
        padding: 0;
        border: none;
      }
      p {
        color: #e6dbff;
      }
    </style>
  </head>
  <body>
    <h1>${escapeHtml(title || "Listing Preview")}</h1>
    ${sectionsHtml || "<p>No preview content available.</p>"}
  </body>
</html>`;
      }

      function suggestNextSku() {
        const last = getLastSku();
        const lastNum = Number.parseInt(last, 10);
        if (Number.isFinite(lastNum)) {
          return String(lastNum + 1);
        }
        return "";
      }

      function updateSkuPanel(data) {
        skuPanel.style.display = "block";
        skuConfirmed = items[currentIndex]?.skuConfirmed || false;

        const existingSku = data?.sku || "";
        const suggested = existingSku || suggestNextSku();
        skuInput.value = suggested;
        skuInput.readOnly = skuConfirmed;

        if (skuConfirmed) {
          skuHint.textContent = `SKU confirmed: ${skuInput.value}.`;
        } else if (existingSku) {
          skuHint.textContent =
            "SKU loaded from file. Click OK to confirm or Change to edit.";
        } else if (suggested) {
          skuHint.textContent = `Suggested next SKU: ${suggested}`;
        } else {
          skuHint.textContent = "Enter your starting SKU and click OK.";
        }
      }

      function confirmSku() {
        if (!currentData) return;
        const value = skuInput.value.trim();
        if (!value) {
          skuHint.textContent = "SKU is empty. Enter a SKU and click OK.";
          return;
        }
        currentData.sku = value;
        setLastSku(value);
        skuConfirmed = true;
        if (items[currentIndex]) {
          items[currentIndex].skuConfirmed = true;
        }
        skuInput.readOnly = true;
        skuHint.textContent = `SKU set to ${value}.`;
        renderFields(currentData);
        saveSession();
      }

      function changeSku() {
        skuConfirmed = false;
        skuInput.readOnly = false;
        skuInput.focus();
        skuHint.textContent = "Enter a new SKU and click OK.";
      }

      skuOkBtn.addEventListener("click", confirmSku);
      skuChangeBtn.addEventListener("click", changeSku);

      function addField(field, data, container) {
        const fieldEl = document.createElement("div");
        fieldEl.className = "field";

        const fieldLabel = document.createElement("label");
        fieldLabel.textContent = field.label;
        if (field.key) {
          fieldLabel.dataset.fieldKey = field.key;
          fieldLabelMap[field.key] = fieldLabel;
        }
        fieldEl.appendChild(fieldLabel);

        const row = document.createElement("div");
        row.className = "row";

        const input = field.multiline
          ? document.createElement("textarea")
          : document.createElement("input");
        const rawValue = field.getValue
          ? field.getValue(data)
          : data
            ? data[field.key]
            : "";
        const displayValue = field.format
          ? field.format(rawValue)
          : toStringValue(rawValue);
        input.value = displayValue;
        const forceReadOnly = Boolean(field.readOnly);
        input.dataset.forceReadonly = forceReadOnly ? "true" : "false";
        input.readOnly = forceReadOnly || !editMode;
        if (
          field.key === "listperfectly_description" &&
          input.tagName === "TEXTAREA"
        ) {
          input.style.minHeight = "400px";
        }
        row.appendChild(input);

        const button = document.createElement("button");
        button.textContent = "Copy";
        button.addEventListener("click", async () => {
          try {
            await navigator.clipboard.writeText(input.value);
            button.textContent = "Copied";
            setTimeout(() => (button.textContent = "Copy"), 1200);
          } catch (err) {
            button.textContent = "Copy failed";
            setTimeout(() => (button.textContent = "Copy"), 1200);
          }
        });
        row.appendChild(button);

        if (field.key) {
          fieldInputMap[field.key] = input;
          const handleFieldInput = () => {
            if (!currentData) return;
            const rawInput = input.value;
            const parsedValue = field.parse ? field.parse(rawInput) : rawInput;
            if (field.setValue) {
              field.setValue(currentData, parsedValue);
            } else {
              currentData[field.key] = parsedValue;
            }
            if (field.key === "tags_line") {
              currentData.tags = parseList(input.value);
            }
            if (field.key === "platforms") {
              currentData.platforms = parsePlatforms(input.value);
            }
            if (field.key === "intended_for") {
              handleMeasurementInput();
            }
            if (field.key === "size_or_fit") {
              syncSizeInputsFromSizeOrFit(currentData);
              handleMeasurementInput();
            }
            if (
              [
                "measurements",
                "measurements_imperial",
                "measurements_metric",
              ].includes(field.key)
            ) {
              return;
            }
            if (
              [
                "hook",
                "description",
                "included_items",
                "measurements",
                "cta",
              ].includes(field.key)
            ) {
              updateListperfectlyDescription(currentData);
            }
            if (["buyer_pays_shipping_price", "msrp"].includes(field.key)) {
              normalizeMsrp(currentData);
            }
            if (
              [
                "purchase_date",
                "purchase_location",
                "offer_recommendation",
              ].includes(field.key)
            ) {
              updateSellerNotes(currentData);
            }
            items[currentIndex].data = currentData;
            saveSession();
            updateCharCounter(field.key);
          };

          input.addEventListener("input", handleFieldInput);
        }

        fieldEl.appendChild(row);
        if (field.key && field.countChars) {
          const counter = document.createElement("div");
          counter.className = "note";
          counter.id = `counter-${field.key}`;
          if (field.maxChars) {
            counter.setAttribute("data-max", String(field.maxChars));
          }
          const maxLabel = field.maxChars ? ` / ${field.maxChars}` : "";
          counter.textContent = `Characters: ${input.value.length}${maxLabel}`;
          fieldEl.appendChild(counter);
        }
        container.appendChild(fieldEl);
        fieldInputs.push(input);
      }

      function updateCharCounter(key) {
        if (!key) return;
        const counter = document.getElementById(`counter-${key}`);
        const input = fieldInputMap[key];
        if (!counter || !input) return;
        const max = counter.getAttribute("data-max");
        const maxLabel = max ? ` / ${max}` : "";
        counter.textContent = `Characters: ${input.value.length}${maxLabel}`;
      }

      function renderFields(data) {
        lpFieldsContainer.innerHTML = "";
        ebayPlatformFieldsContainer.innerHTML = "";
        depopPlatformFieldsContainer.innerHTML = "";
        etsyPlatformFieldsContainer.innerHTML = "";
        poshmarkPlatformFieldsContainer.innerHTML = "";
        mercariPlatformFieldsContainer.innerHTML = "";
        grailedPlatformFieldsContainer.innerHTML = "";
        facebookPlatformFieldsContainer.innerHTML = "";
        shopifyPlatformFieldsContainer.innerHTML = "";
        vestiairePlatformFieldsContainer.innerHTML = "";
        vintedPlatformFieldsContainer.innerHTML = "";
        whatnotPlatformFieldsContainer.innerHTML = "";
        typesMiscFieldsContainer.innerHTML = "";
        additionalFieldsContainer.innerHTML = "";
        if (lpCoreFieldsContainer) {
          lpCoreFieldsContainer.innerHTML = "";
        }
        if (measurementSummaryFieldsContainer) {
          measurementSummaryFieldsContainer.innerHTML = "";
        }
        if (shippingFieldsContainer) {
          shippingFieldsContainer.innerHTML = "";
        }
        fieldInputs = [];
        fieldInputMap = {};
        fieldLabelMap = {};
        const priorityFields = [
          { label: "SKU", key: "sku" },
          { label: "Title", key: "title", countChars: true, maxChars: 80 },
          {
            label: "Short Description (ListPerfectly)",
            key: "listperfectly_description",
            multiline: true,
            readOnly: true,
            countChars: true,
          },
          {
            label: "Buyer pays shipping price",
            key: "buyer_pays_shipping_price",
          },
          { label: "COGS", key: "cogs" },
          { label: "Seller Notes", key: "notes", multiline: true },
          { label: "Purchase Date", key: "purchase_date" },
          { label: "Purchase Location", key: "purchase_location" },
        ];
        const coreFields = [
          { label: "Hook", key: "hook" },
          { label: "Description", key: "description", multiline: true },
          {
            label: "Included Items",
            key: "included_items",
            multiline: true,
            format: (value) => toStringValue(value),
            parse: (value) => parseLines(value),
          },
          { label: "CTA", key: "cta" },
          { label: "Brand / Maker", key: "brand" },
          {
            label: "Color Shade",
            key: "color",
            format: (value) => normalizeColorTags(value),
            parse: (value) => normalizeColorTags(value),
          },
          { label: "Material", key: "material" },
          { label: "Country of Origin", key: "country_of_origin" },
          { label: "Style / Features", key: "style_features" },
          { label: "Size or Fit", key: "size_or_fit" },
          { label: "Tags line", key: "tags_line" },
          {
            label: "Style Tags (boho, mid century modern, etc.)",
            key: "style_tags",
            format: (value) =>
              Array.isArray(value) ? value.join(", ") : toStringValue(value),
            parse: (value) => parseList(value),
          },
          { label: "Condition Status", key: "condition_status" },
          {
            label: "Pre-Owned Condition (Like New/Good/Fair/Poor/None)",
            key: "pre_owned_condition",
          },
          { label: "Condition Notes", key: "condition", multiline: true },
          { label: "MSRP", key: "msrp" },
          { label: "UPC", key: "upc" },
          { label: "Quantity", key: "quantity" },
          {
            label: "Intended For",
            key: "intended_for",
            multiline: true,
            format: (value) =>
              Array.isArray(value) ? value.join(", ") : toStringValue(value),
            parse: (value) => parseList(value),
          },
        ];
        const measurementSummaryFields = [
          {
            label: "Measurements (Combined)",
            key: "measurements",
            multiline: true,
            readOnly: true,
            format: (value) => toStringValue(value),
            parse: (value) => parseList(value),
          },
          {
            label: "Measurements (Imperial)",
            key: "measurements_imperial",
            multiline: true,
            readOnly: true,
            format: (value) => toStringValue(value),
            parse: (value) => parseList(value),
          },
          {
            label: "Measurements (Metric)",
            key: "measurements_metric",
            multiline: true,
            readOnly: true,
            format: (value) => toStringValue(value),
            parse: (value) => parseList(value),
          },
        ];
        const shippingFields = [
          { label: "Shipping Weight (lb)", key: "shipping_weight_lb" },
          { label: "Shipping Weight (oz)", key: "shipping_weight_oz" },
          { label: "Package Length (in)", key: "package_length" },
          { label: "Package Width (in)", key: "package_width" },
          { label: "Package Height (in)", key: "package_height" },
          { label: "Shipping ZIP", key: "shipping_zip" },
        ];

        const ebayPlatformFields = [
          buildPlatformReasonField("eBay", "Ebay Reason"),
          {
            label: "Ebay Types",
            multiline: true,
            getValue: (data) => getTypesParts(data).ebay,
            setValue: (data, value) => setTypesPart(data, "ebay", value),
          },
        ];

        const depopPlatformFields = [
          buildPlatformReasonField("Depop", "Depop Reason"),
          {
            label: "Depop Types",
            multiline: true,
            getValue: (data) => getTypesParts(data).depop,
            setValue: (data, value) => setTypesPart(data, "depop", value),
          },
          {
            label: "Depop Occasions",
            multiline: true,
            getValue: (data) => getTypesParts(data).occasions,
            setValue: (data, value) => setTypesPart(data, "occasions", value),
          },
          {
            label: "Depop Styles",
            multiline: true,
            getValue: (data) => getTypesParts(data).styles,
            setValue: (data, value) => setTypesPart(data, "styles", value),
          },
        ];

        const etsyPlatformFields = [
          buildPlatformReasonField("Etsy", "Etsy Reason"),
        ];
        const poshmarkPlatformFields = [
          buildPlatformReasonField("Poshmark", "Poshmark Reason"),
        ];
        const mercariPlatformFields = [
          buildPlatformReasonField("Mercari", "Mercari Reason"),
        ];
        const grailedPlatformFields = [
          buildPlatformReasonField("Grailed", "Grailed Reason"),
        ];
        const facebookPlatformFields = [
          buildPlatformReasonField(
            "Facebook Marketplace",
            "Facebook Marketplace Reason",
          ),
        ];
        const shopifyPlatformFields = [
          buildPlatformReasonField("Shopify", "Shopify Reason"),
        ];
        const vestiairePlatformFields = [
          buildPlatformReasonField("Vestiaire Collective", "Vestiaire Reason"),
        ];
        const vintedPlatformFields = [
          buildPlatformReasonField("Vinted", "Vinted Reason"),
        ];
        const whatnotPlatformFields = [
          buildPlatformReasonField("Whatnot", "Whatnot Reason"),
        ];

        const miscTypesFields = [
          {
            label: "Other type lines (optional)",
            multiline: true,
            getValue: (data) => getTypesParts(data).misc.join("\n"),
            setValue: (data, value) => setTypesPart(data, "misc", value),
          },
        ];

        const additionalFields = [
          { label: "Listing body", key: "listing_body", multiline: true },
          {
            label: "Pricing sentence",
            key: "pricing_sentence",
            multiline: true,
          },
          { label: "Free shipping price", key: "free_shipping_price" },
          {
            label: "Shipping estimate sentence",
            key: "shipping_estimate_sentence",
            multiline: true,
          },
          { label: "Shipping cost estimate", key: "shipping_cost_estimate" },
          { label: "Platform fee estimate", key: "platform_fee_estimate" },
          {
            label: "Payment processing fee estimate",
            key: "payment_processing_fee_estimate",
          },
          { label: "Labor cost estimate", key: "labor_cost_estimate" },
          { label: "Fees or Other Costs", key: "fees_or_other_costs" },
          { label: "Max profit price", key: "max_profit_price" },
          { label: "Max profit estimate", key: "max_profit_estimate" },
          { label: "Max profit time to sell", key: "max_profit_time_to_sell" },
          { label: "Min profit price", key: "min_profit_price" },
          { label: "Min profit estimate", key: "min_profit_estimate" },
          { label: "Min profit time to sell", key: "min_profit_time_to_sell" },
          { label: "Offer recommendation", key: "offer_recommendation" },
          { label: "Comps day range", key: "comps_day_range" },
          {
            label: "Time-to-sell sentence",
            key: "time_to_sell_sentence",
            multiline: true,
          },
          { label: "Question", key: "question" },
        ];

        priorityFields.forEach((field) =>
          addField(field, data, lpFieldsContainer),
        );
        if (lpCoreFieldsContainer) {
          coreFields.forEach((field) =>
            addField(field, data, lpCoreFieldsContainer),
          );
        }
        if (measurementSummaryFieldsContainer) {
          measurementSummaryFields.forEach((field) =>
            addField(field, data, measurementSummaryFieldsContainer),
          );
        }
        if (shippingFieldsContainer) {
          shippingFields.forEach((field) =>
            addField(field, data, shippingFieldsContainer),
          );
        }
        ebayPlatformFields.forEach((field) =>
          addField(field, data, ebayPlatformFieldsContainer),
        );
        depopPlatformFields.forEach((field) =>
          addField(field, data, depopPlatformFieldsContainer),
        );
        etsyPlatformFields.forEach((field) =>
          addField(field, data, etsyPlatformFieldsContainer),
        );
        poshmarkPlatformFields.forEach((field) =>
          addField(field, data, poshmarkPlatformFieldsContainer),
        );
        mercariPlatformFields.forEach((field) =>
          addField(field, data, mercariPlatformFieldsContainer),
        );
        grailedPlatformFields.forEach((field) =>
          addField(field, data, grailedPlatformFieldsContainer),
        );
        facebookPlatformFields.forEach((field) =>
          addField(field, data, facebookPlatformFieldsContainer),
        );
        shopifyPlatformFields.forEach((field) =>
          addField(field, data, shopifyPlatformFieldsContainer),
        );
        vestiairePlatformFields.forEach((field) =>
          addField(field, data, vestiairePlatformFieldsContainer),
        );
        vintedPlatformFields.forEach((field) =>
          addField(field, data, vintedPlatformFieldsContainer),
        );
        whatnotPlatformFields.forEach((field) =>
          addField(field, data, whatnotPlatformFieldsContainer),
        );
        miscTypesFields.forEach((field) =>
          addField(field, data, typesMiscFieldsContainer),
        );
        additionalFields.forEach((field) =>
          addField(field, data, additionalFieldsContainer),
        );
        updateListperfectlyDescription(data);
        updateSellerNotes(data);
        applyMergedFieldHighlights();
      }

      function updateFieldEditability() {
        fieldInputs.forEach((input) => {
          const forceReadOnly = input.dataset.forceReadonly === "true";
          input.readOnly = forceReadOnly || !editMode;
        });
      }

      updateFieldEditability();
      initMeasurementToggles();

      function handleMeasurementInput(options = {}) {
        const template = getSelectedTemplate();
        if (template === "shoe" || template === "boot") {
          updateSizeOrFitFromHelper(currentData, {
            force: Boolean(options.fromSizeGrid),
          });
        }
        updateMeasurementsFromHelper({ skipSizeNormalize: options.fromSizeGrid });
      }

      const measurementInputs = [
        sizeUsMenInput,
        sizeUsWomenInput,
        sizeUkInput,
        sizeEuInput,
        sizeAuInput,
        sizeWidthInput,
        outsoleLengthInput,
        outsoleWidthInput,
        insoleLengthInput,
        insoleWidthInput,
        heelHeightInput,
        platformHeightInput,
        toeBoxHeightInput,
        weightLbInput,
        weightOzInput,
        shaftHeightInput,
        shaftCircInput,
        calfCircInput,
        garmentChestInput,
        garmentLengthInput,
        garmentShoulderInput,
        garmentSleeveInput,
        garmentWaistInput,
        garmentInseamInput,
        garmentRiseInput,
        garmentHipInput,
        standardLengthInput,
        standardWidthInput,
        standardHeightInput,
      ];

      const sizeGridInputs = [
        sizeUsMenInput,
        sizeUsWomenInput,
        sizeUkInput,
        sizeEuInput,
        sizeAuInput,
        sizeWidthInput,
      ];
      measurementInputs.forEach((input) => {
        if (!input) return;
        const fromSizeGrid = sizeGridInputs.includes(input);
        input.addEventListener("input", () => {
          if (input === sizeUsMenInput) {
            originalSizeRef = null;
            lastSizeEdited = "us_m";
          }
          if (input === sizeUsWomenInput) {
            originalSizeRef = null;
            lastSizeEdited = "us_w";
          }
          if (input === sizeUkInput) {
            originalSizeRef = null;
            lastSizeEdited = "uk";
          }
          if (input === sizeEuInput) {
            originalSizeRef = null;
            lastSizeEdited = "eu";
          }
          if (input === sizeAuInput) {
            originalSizeRef = null;
            lastSizeEdited = "au";
          }
          if (input === sizeWidthInput) {
            originalSizeRef = null;
          }
          updateIncludeToggleForInput(input);
          handleMeasurementInput({ fromSizeGrid });
        });
      });

      if (weightPerSelect) {
        weightPerSelect.addEventListener("change", handleMeasurementInput);
      }

      if (measurementTemplateSelect) {
        measurementTemplateSelect.addEventListener("change", () => {
          toggleMeasurementFields();
          handleMeasurementInput();
        });
      }

      if (saveMeasurementsBtn) {
        saveMeasurementsBtn.addEventListener("click", () => {
          if (!currentData) return;
          handleMeasurementInput();
          saveSession();
          status.textContent = "Measurements saved.";
          setTimeout(() => {
            if (items.length) updateStatus();
          }, 1200);
        });
      }

      jsonBrowseBtn.addEventListener("click", () => {
        jsonPicker.click();
      });

      if (mergeBtn) {
        mergeBtn.addEventListener("click", () => {
          if (!currentData) return;
          if (mergePicker) mergePicker.click();
        });
      }

      if (mergePicker) {
        mergePicker.addEventListener("change", async () => {
          if (!currentData) return;
          const file = mergePicker.files && mergePicker.files[0];
          if (!file) return;
          try {
            const text = await file.text();
            const incoming = JSON.parse(text);
            if (!isLikelySameItem(currentData, incoming)) {
              status.textContent =
                "Merge skipped: selected file does not appear to match this listing.";
              return;
            }
            const result = mergeMissingFields(currentData, incoming);
            if (!result.changed) {
              status.textContent = `Merge complete. No missing fields found in ${file.name}.`;
            } else {
              const details = result.changedKeys.length
                ? ` Updated: ${result.changedKeys.join(", ")}.`
                : "";
              status.textContent = `Merged missing fields from ${file.name}.${details}`;
            }
            items[currentIndex].data = currentData;
            setMergedFieldKeys(result.changedFieldKeys || []);
            setMergedMeasurementLabelKeys(
              result.measurementIncomingLabels?.length
                ? result.measurementIncomingLabels
                : result.measurementAddedLabels || [],
            );
            updateSkuPanel(currentData);
            renderFields(currentData);
            normalizeMsrp(currentData);
            updateListperfectlyDescription(currentData);
            updateSellerNotes(currentData);
            toggleMeasurementFields();
            populateMeasurementHelperFromData(currentData);
            applyIncludeDefaultsFromInputs();
            if (
              result.measurementLinesAdded ||
              result.measurementIncomingLabels?.length
            ) {
              autoEnableIncludeTogglesFromMeasurements(currentData);
            }
            applyMeasurementInputHighlights();
            updateFieldEditability();
            saveSession();
            mergePicker.value = "";
          } catch (err) {
            status.textContent = `Could not parse JSON: ${file.name}`;
          }
        });
      }

      if (terapeakBtn) {
        terapeakBtn.addEventListener("click", () => {
          if (!currentData) return;
          const url = buildTerapeakUrl(currentData);
          window.open(url, "_blank");
        });
      }

      jsonPicker.addEventListener("change", () => {
        const file = jsonPicker.files && jsonPicker.files[0];
        if (!file) return;
        const currentPath = jsonPathInput.value.trim();
        const hasJsonPath = currentPath.toLowerCase().endsWith(".json");
        const baseFolder = hasJsonPath
          ? currentPath.slice(0, Math.max(0, currentPath.lastIndexOf("\\")))
          : currentPath.replace(/\\+$/g, "");
        const folderToUse = baseFolder || defaultJsonFolder;
        if (folderToUse) {
          jsonPathInput.value = `${folderToUse}\\${file.name}`;
        } else {
          jsonPathInput.value = file.name;
        }
        autofillNote.textContent = `Selected ${file.name}. Path was auto-filled; edit if needed.`;
        saveAutofillInputs();
      });

      function loadSavedAutofillInputs() {
        const savedProject = window.localStorage.getItem("moola_project_path");
        if (savedProject) {
          if (savedProject.includes("Moola-Matic")) {
            projectPathInput.value =
              "C:\\\\Users\\\\outdo\\\\Documents\\\\MOOLA-MATIC MINI";
            window.localStorage.setItem(
              "moola_project_path",
              projectPathInput.value,
            );
          } else {
            projectPathInput.value = savedProject;
          }
        }
        if (!projectPathInput.value) {
          projectPathInput.value =
            "C:\\\\Users\\\\outdo\\\\Documents\\\\MOOLA-MATIC MINI";
        }
        jsonPathInput.value = "C:\\\\Users\\\\outdo\\\\Downloads";
        const current = jsonPathInput.value.trim();
        if (current.includes("\\")) {
          if (current.toLowerCase().endsWith(".json")) {
            defaultJsonFolder = current.slice(0, current.lastIndexOf("\\"));
          } else {
            defaultJsonFolder = current.replace(/\\+$/g, "");
          }
        }
      }

      function saveAutofillInputs() {
        if (projectPathInput.value) {
          window.localStorage.setItem(
            "moola_project_path",
            projectPathInput.value,
          );
        }
        if (jsonPathInput.value) {
          window.localStorage.setItem("moola_json_path", jsonPathInput.value);
        }
      }

      function buildAutofillCommand() {
        const projectPath = projectPathInput.value.trim();
        const jsonPath = jsonPathInput.value.trim();
        if (!projectPath || !jsonPath) return "";
        const scriptPath = `${projectPath}\\playwright-assistant\\scripts\\run-playwright.js`;
        const selectorsPath = `${projectPath}\\playwright-assistant\\scripts\\selectors.json`;
        const userDataDir = `${projectPath}\\playwright-assistant\\.user-data`;
        return `node \"${scriptPath}\" --safe --json \"${jsonPath}\" --selectors \"${selectorsPath}\" --user-data-dir \"${userDataDir}\"`;
      }

      function isJsonFilePath(value) {
        return String(value || "")
          .trim()
          .toLowerCase()
          .endsWith(".json");
      }

      function ensureJsonPathIsFile() {
        const jsonPath = jsonPathInput.value.trim();
        if (!jsonPath) return false;
        if (isJsonFilePath(jsonPath)) return true;
        autofillNote.textContent =
          "Download the JSON first, then paste the full .json file path.";
        return false;
      }

      copyCmdBtn.addEventListener("click", async () => {
        saveAutofillInputs();
        if (!ensureJsonPathIsFile()) return;
        const cmd = buildAutofillCommand();
        if (!cmd) {
          autofillNote.textContent =
            "Enter the project path and JSON file path first.";
          return;
        }
        try {
          await navigator.clipboard.writeText(cmd);
          autofillNote.textContent = "Autofill command copied.";
        } catch (err) {
          autofillNote.textContent =
            "Could not copy. You can still download the .bat file.";
        }
      });

      downloadBatBtn.addEventListener("click", () => {
        saveAutofillInputs();
        if (!ensureJsonPathIsFile()) return;
        const cmd = buildAutofillCommand();
        if (!cmd) {
          autofillNote.textContent =
            "Enter the project path and JSON file path first.";
          return;
        }
        const content = `@echo off\r\n${cmd}\r\npause\r\n`;
        const blob = new Blob([content], { type: "text/plain" });
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        link.href = url;
        link.download = "run-autofill.bat";
        document.body.appendChild(link);
        link.click();
        link.remove();
        URL.revokeObjectURL(url);
        autofillNote.textContent =
          "run-autofill.bat downloaded. Double-click it to run.";
      });

      function updateStatus() {
        if (!items.length) {
          status.textContent = "No file loaded.";
          prevBtn.disabled = true;
          nextBtn.disabled = true;
          return;
        }
        const current = items[currentIndex];
        status.textContent = `Loaded ${items.length} file(s). Viewing ${
          currentIndex + 1
        } of ${items.length}: ${current.name}`;
        prevBtn.disabled = currentIndex === 0;
        nextBtn.disabled = currentIndex === items.length - 1;
      }

      function loadCurrent() {
        if (!items.length) return;
        includeDefaultsApplied = false;
        setMergedFieldKeys([]);
        setMergedMeasurementLabelKeys([]);
        currentData = items[currentIndex].data;
        lpPanel.style.display = "block";
        measurementsHelperPanel.style.display = "block";
        shippingPanel.style.display = "block";
        corePanel.style.display = "block";
        platformPanel.style.display = "block";
        additionalPanel.style.display = "block";
        updateSkuPanel(currentData);
        renderFields(currentData);
        normalizeMsrp(currentData);
        updateFieldEditability();
        toggleMeasurementFields();
        resetMeasurementHelper();
        populateMeasurementHelperFromData(currentData);
        applyIncludeDefaultsFromInputs();
        updateMeasurementsFromHelper();
        downloadBtn.disabled = false;
        if (previewBtn) previewBtn.disabled = false;
        if (mergeBtn) mergeBtn.disabled = false;
        if (terapeakBtn) terapeakBtn.disabled = false;
        updateStatus();
        saveSession();
      }

      prevBtn.addEventListener("click", () => {
        if (currentIndex > 0) {
          currentIndex -= 1;
          loadCurrent();
        }
      });

      nextBtn.addEventListener("click", () => {
        if (!skuConfirmed) {
          skuHint.textContent = "Confirm SKU first, then click Next.";
          return;
        }
        if (currentIndex < items.length - 1) {
          currentIndex += 1;
          loadCurrent();
        }
      });

      fileInput.addEventListener("change", async (event) => {
        const files = Array.from(event.target.files || []);
        if (!files.length) return;
        clearSession();
        items = [];
        for (const file of files) {
          try {
            const text = await file.text();
            const data = JSON.parse(text);
            items.push({ name: file.name, data, skuConfirmed: false });
          } catch (err) {
            status.textContent = `Could not parse JSON: ${file.name}`;
          }
        }
        if (!items.length) {
          resetToEmpty();
          return;
        }
        currentIndex = 0;
        skuPanel.style.display = "block";
        loadCurrent();
        setDefaultPanelStateWhenLoaded();
      });

      loadSavedAutofillInputs();
      loadSession();

      downloadBtn.addEventListener("click", () => {
        if (!currentData) return;
        normalizeMsrp(currentData);
        updateListperfectlyDescription(currentData);
        const filename = buildFilename(currentData);
        const blob = new Blob([JSON.stringify(currentData, null, 2)], {
          type: "application/json",
        });
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        link.href = url;
        link.download = filename;
        document.body.appendChild(link);
        link.click();
        link.remove();
        URL.revokeObjectURL(url);
        jsonPathInput.value = `C:\\\\Users\\\\outdo\\\\Downloads\\\\${filename}`;
        saveAutofillInputs();
        clearMergedFieldHighlights();
      });

      if (previewBtn) {
        previewBtn.addEventListener("click", () => {
          if (!currentData) return;
          const html = buildPreviewHtml(currentData);
          const win = window.open("", "_blank");
          if (!win) return;
          win.document.write(html);
          win.document.close();
        });
      }

      if (expandAllBtn) {
        expandAllBtn.addEventListener("click", () => {
          document.querySelectorAll("details.panel").forEach((panel) => {
            panel.open = true;
          });
        });
      }

      if (collapseAllBtn) {
        collapseAllBtn.addEventListener("click", () => {
          document.querySelectorAll("details.panel").forEach((panel) => {
            panel.open = false;
          });
        });
      }

      if (clearAllBtn) {
        clearAllBtn.addEventListener("click", () => {
          clearSession();
          resetMeasurementHelper();
          resetToEmpty();
        });
      }
    </script>
  </body>
</html>
