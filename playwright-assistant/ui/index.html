<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Moola Playwright Helper</title>
    <style>
      :root {
        color-scheme: dark;
        font-family: "Segoe UI", Arial, Helvetica, sans-serif;
        --violet-950: #0f0a1d;
        --violet-900: #1b1033;
        --violet-800: #2a1650;
        --violet-700: #3c1e6b;
        --violet-500: #7c3aed;
        --violet-300: #c4b5fd;
        --violet-200: #d8ccff;
        --ink-100: #f4f0ff;
        --ink-200: #d9cff6;
      }

      html,
      body {
        min-height: 100%;
      }
      body {
        margin: 0;
        color: var(--ink-100);
        background: radial-gradient(
          circle at top,
          #22113f 0%,
          #120a22 45%,
          #0b0814 100%
        );
        background-repeat: no-repeat;
        background-attachment: fixed;
      }
      .wrap {
        max-width: 980px;
        margin: 0 auto;
        padding: 28px 22px 48px;
      }
      h1 {
        margin: 0 0 8px;
        font-size: 28px;
        color: var(--ink-100);
      }
      h2 {
        margin: 0 0 10px;
        font-size: 18px;
        color: var(--violet-200);
      }
      p {
        margin: 6px 0 16px;
        color: var(--ink-200);
      }
      .panel {
        border: 1px solid #3a245c;
        border-radius: 14px;
        padding: 16px 18px;
        margin: 14px 0;
        background: rgba(19, 12, 33, 0.9);
        box-shadow: 0 8px 24px rgba(12, 8, 22, 0.7);
      }
      .panel summary {
        cursor: pointer;
        list-style: none;
      }
      .panel summary::-webkit-details-marker {
        display: none;
      }
      .panel summary h2 {
        margin: 0;
      }
      .panel[open] summary {
        margin-bottom: 10px;
      }
      .field {
        margin: 14px 0;
      }
      .field label {
        display: block;
        font-weight: 600;
        margin-bottom: 8px;
        color: var(--violet-200);
      }
      .field input,
      .field textarea,
      .field select {
        width: 100%;
        padding: 10px 12px;
        border: 1px solid #3b2a63;
        border-radius: 10px;
        font-size: 14px;
        box-sizing: border-box;
        background: #1a102b;
        color: var(--ink-100);
      }
      .field input:focus,
      .field textarea:focus {
        outline: 2px solid #5b3a9f;
        border-color: var(--violet-500);
        background: #201236;
      }
      .field textarea {
        min-height: 96px;
        resize: vertical;
      }
      .row {
        display: flex;
        gap: 10px;
        align-items: center;
        flex-wrap: wrap;
      }
      .row button {
        padding: 9px 14px;
        border: 1px solid #6b3ddb;
        background: linear-gradient(145deg, #7c3aed, #5b2fc7);
        color: #fff;
        border-radius: 10px;
        cursor: pointer;
        font-weight: 600;
        transition: transform 0.05s ease, box-shadow 0.15s ease;
      }
      .row button:hover {
        box-shadow: 0 8px 16px rgba(124, 58, 237, 0.35);
      }
      .row button:active {
        transform: translateY(1px);
      }
      .row button:disabled {
        opacity: 0.45;
        cursor: not-allowed;
        background: #3b275e;
        border-color: #3b275e;
        box-shadow: none;
      }
      .note {
        font-size: 12px;
        color: #b29adf;
      }
      .section-title {
        margin: 14px 0 6px;
        font-size: 14px;
        color: var(--violet-200);
        font-weight: 600;
      }
      .inline-check {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        font-size: 12px;
        color: #b29adf;
      }
      .inline-check input {
        width: auto;
      }
      .status {
        margin-top: 8px;
        font-size: 14px;
        color: #bba6e7;
      }
      #fileInput {
        padding: 8px;
        background: #130c21;
        color: var(--ink-100);
        border: 1px solid #3b2a63;
        border-radius: 8px;
      }
    </style>
  </head>
  <body>
    <div class="wrap">
      <h1>Moola Playwright Helper</h1>
      <p>Load your listing JSON, then copy fields into your listing form.</p>
      <div class="row" style="margin: 8px 0 14px">
        <button id="expandAllBtn" type="button">Expand all</button>
        <button id="collapseAllBtn" type="button">Collapse all</button>
        <button id="clearAllBtn" type="button">Clear All</button>
      </div>

      <details class="panel" open>
        <summary><h2>JSON Loader</h2></summary>
        <div class="row">
          <input type="file" id="fileInput" accept=".json" multiple />
          <button id="downloadBtn" disabled>Download JSON</button>
          <button id="previewBtn" disabled>Preview Listing</button>
          <button id="mergeBtn" disabled>Update/Merge JSON</button>
          <button id="prevBtn" disabled>Prev</button>
          <button id="nextBtn" disabled>Next</button>
        </div>
        <input
          id="mergePicker"
          type="file"
          accept=".json"
          style="display: none"
        />
        <div class="note" style="margin-top: 10px">
          Edit mode is always on. Edits update the JSON used for auto‑fill and
          download.
        </div>
        <div class="status" id="status">No file loaded.</div>
        <div class="note">
          Generate JSON with /run-moola List, then load it here to review/edit.
        </div>
        <div class="note">
          This page never shows raw JSON. It only displays copy-ready fields.
        </div>
      </details>

      <details class="panel" id="autofillPanel">
        <summary><h2>Auto‑fill helper</h2></summary>
        <div class="field">
          <label>Project folder path</label>
          <input
            id="projectPathInput"
            type="text"
            placeholder="C:\\Users\\outdo\\Documents\\MOOLA-MATIC MINI"
          />
        </div>
        <div class="field">
          <label>JSON file path</label>
          <input
            id="jsonPathInput"
            type="text"
            placeholder="C:\\Users\\outdo\\Downloads\\listing.json"
          />
        </div>
        <div class="row">
          <input
            id="jsonPicker"
            type="file"
            accept=".json"
            style="display: none"
          />
          <button id="jsonBrowseBtn">Browse JSON</button>
        </div>
        <div class="row">
          <button id="copyCmdBtn">Copy autofill command</button>
          <button id="downloadBatBtn">Download run-autofill.bat</button>
        </div>
        <div class="note" id="autofillNote">
          Browsers can’t run Playwright directly. Use the copied command or the
          .bat file.
        </div>
        <div class="note" style="margin-top: 8px">
          Need PowerShell? Press the Windows key, type "PowerShell", and open
          Windows PowerShell.
        </div>
      </details>

      <details id="skuPanel" class="panel" style="display: none" open>
        <summary><h2>SKU</h2></summary>
        <div class="field">
          <label>SKU</label>
          <div class="row">
            <input id="skuInput" type="text" placeholder="Enter SKU" />
            <button id="skuOkBtn">OK</button>
            <button id="skuChangeBtn">Change</button>
          </div>
          <div class="note" id="skuHint"></div>
        </div>
      </details>

      <details id="lpPanel" class="panel" style="display: none" open>
        <summary><h2>ListPerfectly selectors (auto-fill priority)</h2></summary>
        <div class="note" style="margin-top: 6px">
          Includes combined fields like intended_for, tags_line, condition
          notes, and measurements. Package measurements are L x W x H (in).
        </div>
        <div id="lpFields"></div>
      </details>

      <details
        id="measurementsHelperPanel"
        class="panel"
        style="display: none"
        open
      >
        <summary><h2>Measurements helper</h2></summary>
        <div class="note" style="margin-top: 6px">
          Enter inches; cm is auto-calculated. Auto-generated values use "~".
        </div>
        <div class="field">
          <label>Measurements verified</label>
          <div class="row">
            <input id="measurementsVerifiedToggle" type="checkbox" />
            <button id="saveVerifiedBtn" type="button">Save verified</button>
          </div>
        </div>
        <div class="field">
          <label>Measurement template</label>
          <select id="measurementTemplateSelect">
            <option value="auto">Auto (detect)</option>
            <option value="shoe">Shoes</option>
            <option value="boot">Boots</option>
            <option value="garment">Garments</option>
            <option value="standard">Standard L/W/H</option>
          </select>
        </div>
        <div id="shoeFields">
          <div class="field">
            <label>Size tag (US / UK / EU / Width)</label>
            <div class="row">
              <input id="sizeUsInput" type="text" placeholder="US" />
              <input id="sizeUkInput" type="text" placeholder="UK" />
              <input id="sizeEuInput" type="text" placeholder="EU" />
              <input
                id="sizeWidthInput"
                type="text"
                placeholder="Width (Reg/Wide/Extra Wide/XXWide/Narrow)"
              />
            </div>
            <div class="note">
              Width note: Reg, Wide, Extra Wide, XXWide, Narrow. Default to Reg.
            </div>
          </div>
          <div class="field">
            <label>Outsole length (heel-to-toe, in)</label>
            <input id="outsoleLengthInput" type="number" step="0.1" />
          </div>
          <div class="field">
            <label>Outsole width (widest part, in)</label>
            <input id="outsoleWidthInput" type="number" step="0.1" />
          </div>
          <div class="field">
            <label>Insole length (heel cup to toe, in)</label>
            <input id="insoleLengthInput" type="number" step="0.1" />
          </div>
          <div class="field">
            <label>Insole width (ball area, in)</label>
            <input id="insoleWidthInput" type="number" step="0.1" />
          </div>
          <div class="field">
            <label>Heel height (floor to top of heel, in)</label>
            <input id="heelHeightInput" type="number" step="0.1" />
          </div>
          <div class="field">
            <label>Platform height (forefoot, in)</label>
            <input id="platformHeightInput" type="number" step="0.1" />
          </div>
          <div class="field">
            <label>Toe box height (inside height at toes, in)</label>
            <input id="toeBoxHeightInput" type="number" step="0.1" />
          </div>
          <div class="field">
            <label>Weight (lb)</label>
            <div class="row">
              <input id="weightValueInput" type="number" step="0.1" />
              <select id="weightPerSelect">
                <option value="pair">Per pair</option>
                <option value="boot">Per boot</option>
              </select>
            </div>
          </div>
        </div>
        <div id="bootFields">
          <div class="field">
            <label>Shaft height (top of outsole to top, in)</label>
            <input id="shaftHeightInput" type="number" step="0.1" />
          </div>
          <div class="field">
            <label>Shaft opening / circumference (in)</label>
            <input id="shaftCircInput" type="number" step="0.1" />
          </div>
          <div class="field">
            <label>Calf circumference (widest point, in)</label>
            <input id="calfCircInput" type="number" step="0.1" />
          </div>
        </div>
        <div id="garmentFields">
          <div class="field">
            <label>Chest (pit to pit, in)</label>
            <input id="garmentChestInput" type="number" step="0.1" />
          </div>
          <div class="field">
            <label>Length (shoulder to hem, in)</label>
            <input id="garmentLengthInput" type="number" step="0.1" />
          </div>
          <div class="field">
            <label>Shoulder width (in)</label>
            <input id="garmentShoulderInput" type="number" step="0.1" />
          </div>
          <div class="field">
            <label>Sleeve length (in)</label>
            <input id="garmentSleeveInput" type="number" step="0.1" />
          </div>
          <div class="field">
            <label>Waist (in)</label>
            <input id="garmentWaistInput" type="number" step="0.1" />
          </div>
          <div class="field">
            <label>Inseam (in)</label>
            <input id="garmentInseamInput" type="number" step="0.1" />
          </div>
          <div class="field">
            <label>Rise (in)</label>
            <input id="garmentRiseInput" type="number" step="0.1" />
          </div>
          <div class="field">
            <label>Hip (in)</label>
            <input id="garmentHipInput" type="number" step="0.1" />
          </div>
        </div>
        <div id="standardFields">
          <div class="field">
            <label>Length (in)</label>
            <input id="standardLengthInput" type="number" step="0.1" />
          </div>
          <div class="field">
            <label>Width (in)</label>
            <input id="standardWidthInput" type="number" step="0.1" />
          </div>
          <div class="field">
            <label>Height (in)</label>
            <input id="standardHeightInput" type="number" step="0.1" />
          </div>
        </div>
      </details>

      <details id="platformPanel" class="panel" style="display: none" open>
        <summary><h2>Platform specifics</h2></summary>
        <div class="note" style="margin-top: 6px">
          Platform-specific reasons and types grouped by platform.
        </div>
        <div class="section-title">Ebay</div>
        <div id="ebayPlatformFields"></div>
        <div class="section-title">Depop</div>
        <div id="depopPlatformFields"></div>
        <div class="section-title">Misc Types (Occasions/Styles)</div>
        <div id="typesMiscFields"></div>
        <div class="section-title">Other Platforms</div>
        <div id="otherPlatformFields"></div>
      </details>

      <details id="additionalPanel" class="panel" style="display: none" open>
        <summary><h2>Additional information</h2></summary>
        <div class="note" style="margin-top: 6px">
          Listing content and other non-selector fields.
        </div>
        <div id="additionalFields"></div>
      </details>
    </div>

    <script>
      const fileInput = document.getElementById("fileInput");
      const downloadBtn = document.getElementById("downloadBtn");
      const previewBtn = document.getElementById("previewBtn");
      const mergeBtn = document.getElementById("mergeBtn");
      const expandAllBtn = document.getElementById("expandAllBtn");
      const collapseAllBtn = document.getElementById("collapseAllBtn");
      const clearAllBtn = document.getElementById("clearAllBtn");
      const lpPanel = document.getElementById("lpPanel");
      const measurementsHelperPanel = document.getElementById(
        "measurementsHelperPanel"
      );
      const platformPanel = document.getElementById("platformPanel");
      const additionalPanel = document.getElementById("additionalPanel");
      const lpFieldsContainer = document.getElementById("lpFields");
      const ebayPlatformFieldsContainer =
        document.getElementById("ebayPlatformFields");
      const depopPlatformFieldsContainer = document.getElementById(
        "depopPlatformFields"
      );
      const typesMiscFieldsContainer =
        document.getElementById("typesMiscFields");
      const otherPlatformFieldsContainer = document.getElementById(
        "otherPlatformFields"
      );
      const additionalFieldsContainer =
        document.getElementById("additionalFields");
      const status = document.getElementById("status");
      const prevBtn = document.getElementById("prevBtn");
      const nextBtn = document.getElementById("nextBtn");
      const projectPathInput = document.getElementById("projectPathInput");
      const jsonPathInput = document.getElementById("jsonPathInput");
      const jsonPicker = document.getElementById("jsonPicker");
      const mergePicker = document.getElementById("mergePicker");
      const jsonBrowseBtn = document.getElementById("jsonBrowseBtn");
      const copyCmdBtn = document.getElementById("copyCmdBtn");
      const downloadBatBtn = document.getElementById("downloadBatBtn");
      const autofillNote = document.getElementById("autofillNote");
      const skuPanel = document.getElementById("skuPanel");
      const skuInput = document.getElementById("skuInput");
      const skuOkBtn = document.getElementById("skuOkBtn");
      const skuChangeBtn = document.getElementById("skuChangeBtn");
      const skuHint = document.getElementById("skuHint");
      const autoMeasurementsToggle = null;
      const measurementsVerifiedToggle = document.getElementById(
        "measurementsVerifiedToggle"
      );
      const saveVerifiedBtn = document.getElementById("saveVerifiedBtn");
      const measurementTemplateSelect = document.getElementById(
        "measurementTemplateSelect"
      );
      const shoeFields = document.getElementById("shoeFields");
      const bootFields = document.getElementById("bootFields");
      const garmentFields = document.getElementById("garmentFields");
      const standardFields = document.getElementById("standardFields");
      const sizeUsInput = document.getElementById("sizeUsInput");
      const sizeUkInput = document.getElementById("sizeUkInput");
      const sizeEuInput = document.getElementById("sizeEuInput");
      const sizeWidthInput = document.getElementById("sizeWidthInput");
      const outsoleLengthInput = document.getElementById("outsoleLengthInput");
      const outsoleWidthInput = document.getElementById("outsoleWidthInput");
      const insoleLengthInput = document.getElementById("insoleLengthInput");
      const insoleWidthInput = document.getElementById("insoleWidthInput");
      const heelHeightInput = document.getElementById("heelHeightInput");
      const platformHeightInput = document.getElementById(
        "platformHeightInput"
      );
      const toeBoxHeightInput = document.getElementById("toeBoxHeightInput");
      const weightValueInput = document.getElementById("weightValueInput");
      const weightPerSelect = document.getElementById("weightPerSelect");
      const shaftHeightInput = document.getElementById("shaftHeightInput");
      const shaftCircInput = document.getElementById("shaftCircInput");
      const calfCircInput = document.getElementById("calfCircInput");
      const garmentChestInput = document.getElementById("garmentChestInput");
      const garmentLengthInput = document.getElementById("garmentLengthInput");
      const garmentShoulderInput = document.getElementById(
        "garmentShoulderInput"
      );
      const garmentSleeveInput = document.getElementById("garmentSleeveInput");
      const garmentWaistInput = document.getElementById("garmentWaistInput");
      const garmentInseamInput = document.getElementById("garmentInseamInput");
      const garmentRiseInput = document.getElementById("garmentRiseInput");
      const garmentHipInput = document.getElementById("garmentHipInput");
      const standardLengthInput = document.getElementById(
        "standardLengthInput"
      );
      const standardWidthInput = document.getElementById("standardWidthInput");
      const standardHeightInput = document.getElementById(
        "standardHeightInput"
      );
      let items = [];
      let currentIndex = 0;
      let currentData = null;
      let skuConfirmed = false;
      let editMode = true;
      let fieldInputs = [];
      let fieldInputMap = {};
      let lastAutoNotes = "";
      let lastAutoSize = "";
      let includeToggles = {};
      let measurementTogglePairs = [];
      let includeDefaultsApplied = false;
      let defaultJsonFolder = "C:\\\\Users\\\\outdo\\\\Downloads";
      const sessionStorageKey = "moola_session_data";

      function toStringValue(value) {
        if (value === null || value === undefined) return "";
        if (Array.isArray(value)) {
          return value
            .map((item) => {
              if (item && typeof item === "object") {
                const platform = item.platform || "";
                const reason = item.reason || "";
                return platform && reason
                  ? `${platform}: ${reason}`
                  : platform || reason;
              }
              return String(item);
            })
            .join("\n");
        }
        if (typeof value === "object") return JSON.stringify(value);
        return String(value);
      }

      function parseList(value) {
        return String(value || "")
          .split(/[,\n]/)
          .map((item) => item.trim())
          .filter(Boolean);
      }

      function normalizeKey(value) {
        return String(value || "")
          .toLowerCase()
          .replace(/[^a-z0-9]/g, "");
      }

      function isBlankString(value) {
        return !String(value || "").trim();
      }

      function isBlankArray(value) {
        if (!Array.isArray(value)) return true;
        if (!value.length) return true;
        return value.every((item) => !String(item || "").trim());
      }

      function getMatchScore(base, incoming) {
        const pairs = [
          { key: "sku", weight: 2 },
          { key: "title", weight: 2 },
          { key: "brand", weight: 1 },
          { key: "size_or_fit", weight: 1 },
          { key: "upc", weight: 1 },
        ];
        let score = 0;
        pairs.forEach(({ key, weight }) => {
          const a = normalizeKey(base?.[key]);
          const b = normalizeKey(incoming?.[key]);
          if (a && b && a === b) score += weight;
        });
        return score;
      }

      function isLikelySameItem(base, incoming) {
        if (!base || !incoming) return false;
        const skuMatch =
          normalizeKey(base.sku) &&
          normalizeKey(base.sku) === normalizeKey(incoming.sku);
        const titleMatch =
          normalizeKey(base.title) &&
          normalizeKey(base.title) === normalizeKey(incoming.title);
        const brandMatch =
          normalizeKey(base.brand) &&
          normalizeKey(base.brand) === normalizeKey(incoming.brand);
        const score = getMatchScore(base, incoming);
        if (skuMatch) return true;
        if (titleMatch && brandMatch) return true;
        return score >= 3;
      }

      function mergeMissingFields(base, incoming) {
        if (!base || !incoming) return false;
        let changed = false;
        Object.keys(incoming).forEach((key) => {
          const incomingValue = incoming[key];
          if (key === "platforms") {
            if (!Array.isArray(incomingValue) || !incomingValue.length) return;
            if (!Array.isArray(base.platforms) || !base.platforms.length) {
              base.platforms = incomingValue;
              changed = true;
              return;
            }
            const existing = new Set(
              base.platforms
                .map((item) => normalizeKey(item?.platform))
                .filter(Boolean)
            );
            incomingValue.forEach((item) => {
              const name = normalizeKey(item?.platform);
              if (!name || existing.has(name)) return;
              base.platforms.push(item);
              existing.add(name);
              changed = true;
            });
            return;
          }
          if (Array.isArray(incomingValue)) {
            if (isBlankArray(base[key]) && !isBlankArray(incomingValue)) {
              base[key] = incomingValue;
              changed = true;
            }
            return;
          }
          if (incomingValue && typeof incomingValue === "object") {
            return;
          }
          if (isBlankString(base[key]) && !isBlankString(incomingValue)) {
            base[key] = incomingValue;
            changed = true;
          }
        });

        if (
          isBlankString(base.tags_line) &&
          !isBlankString(incoming.tags_line)
        ) {
          base.tags_line = incoming.tags_line;
          if (isBlankArray(base.tags)) {
            base.tags = parseList(incoming.tags_line);
          }
          changed = true;
        }
        if (isBlankArray(base.tags) && !isBlankArray(incoming.tags)) {
          base.tags = incoming.tags;
          changed = true;
        }
        return changed;
      }

      function capitalizeWords(text) {
        return String(text || "")
          .toLowerCase()
          .split(/\s+/)
          .map((word) => (word ? word[0].toUpperCase() + word.slice(1) : ""))
          .join(" ")
          .trim();
      }

      function normalizeColorTags(value) {
        const tags = parseList(value);
        if (!tags.length) return "";
        return tags.map((tag) => capitalizeWords(tag)).join(", ");
      }

      function parseLines(value) {
        return String(value || "")
          .split(/\\n/)
          .map((item) => item.trim())
          .filter(Boolean);
      }

      function parsePlatforms(value) {
        const lines = String(value || "")
          .split(/\\n/)
          .map((line) => line.trim())
          .filter(Boolean);
        return lines.map((line) => {
          const idx = line.indexOf(":");
          if (idx === -1) {
            return { platform: line, reason: "" };
          }
          return {
            platform: line.slice(0, idx).trim(),
            reason: line.slice(idx + 1).trim(),
          };
        });
      }

      function getTypesParts(data) {
        const text = String(data?.types_block || "");
        const depopMatch = text.match(
          /^(?:Depop Boots Type|Depop Types):\s*(.+)$/im
        );
        const ebayMatch = text.match(
          /^(?:Ebay Boots Type|Ebay Types):\s*(.+)$/im
        );
        const occasionsMatch = text.match(/^Occasions:\s*(.+)$/im);
        const stylesMatch = text.match(/^Styles:\s*(.+)$/im);
        const depop = depopMatch ? depopMatch[1].trim() : "";
        const ebay = ebayMatch ? ebayMatch[1].trim() : "";
        const occasions = occasionsMatch ? occasionsMatch[1].trim() : "";
        const styles = stylesMatch ? stylesMatch[1].trim() : "";
        const lines = text
          .split(/\\n/)
          .map((line) => line.trim())
          .filter(Boolean);
        const misc = lines.filter((line) => {
          const lower = line.toLowerCase();
          if (lower.startsWith("depop boots type:")) return false;
          if (lower.startsWith("depop types:")) return false;
          if (lower.startsWith("ebay boots type:")) return false;
          if (lower.startsWith("ebay types:")) return false;
          if (lower.startsWith("occasions:")) return false;
          if (lower.startsWith("styles:")) return false;
          return true;
        });
        return { depop, ebay, occasions, styles, misc };
      }

      function buildTypesBlock(parts) {
        const lines = [];
        if (parts.depop) {
          lines.push(`Depop Boots Type: ${parts.depop}`);
        }
        if (parts.ebay) {
          lines.push(`Ebay Boots Type: ${parts.ebay}`);
        }
        if (parts.occasions) {
          lines.push(`Occasions: ${parts.occasions}`);
        }
        if (parts.styles) {
          lines.push(`Styles: ${parts.styles}`);
        }
        if (parts.misc?.length) {
          lines.push(...parts.misc);
        }
        return lines.join("\\n");
      }

      function setTypesPart(data, part, value) {
        if (!data) return;
        const parts = getTypesParts(data);
        if (part === "depop") parts.depop = String(value || "").trim();
        if (part === "ebay") parts.ebay = String(value || "").trim();
        if (part === "occasions") parts.occasions = String(value || "").trim();
        if (part === "styles") parts.styles = String(value || "").trim();
        if (part === "misc") {
          parts.misc = String(value || "")
            .split(/\\n/)
            .map((line) => line.trim())
            .filter(Boolean);
        }
        data.types_block = buildTypesBlock(parts);
      }

      function getPlatformReason(data, platform) {
        const list = Array.isArray(data?.platforms) ? data.platforms : [];
        const match = list.find(
          (item) =>
            String(item?.platform || "").toLowerCase() ===
            platform.toLowerCase()
        );
        return match?.reason || "";
      }

      function setPlatformReason(data, platform, reason) {
        if (!data) return;
        const trimmed = String(reason || "").trim();
        const list = Array.isArray(data.platforms) ? data.platforms : [];
        const idx = list.findIndex(
          (item) =>
            String(item?.platform || "").toLowerCase() ===
            platform.toLowerCase()
        );
        if (!trimmed) {
          if (idx >= 0) list.splice(idx, 1);
          data.platforms = list;
          return;
        }
        if (idx >= 0) {
          list[idx].reason = trimmed;
        } else {
          list.push({ platform, reason: trimmed });
        }
        data.platforms = list;
      }

      function buildListperfectlyDescription(data) {
        const parts = [];
        const hook = String(data?.hook || "").trim();
        if (hook) parts.push(hook);

        const description = String(data?.description || "").trim();
        if (description) parts.push(description);

        const includedItems = Array.isArray(data?.included_items)
          ? data.included_items
          : parseLines(data?.included_items);
        const cleanIncluded = includedItems
          .map((item) => String(item || "").trim())
          .filter(Boolean);
        if (cleanIncluded.length) {
          parts.push(
            `You will receive the following item(s):\n${cleanIncluded
              .map((item) => `- ${item}`)
              .join("\n")}`
          );
        }

        const measurements = Array.isArray(data?.measurements)
          ? data.measurements
          : parseList(data?.measurements);
        const cleanMeasurements = measurements
          .map((item) => String(item || "").trim())
          .filter(Boolean);
        if (cleanMeasurements.length) {
          parts.push(
            `Measurements:\n${cleanMeasurements
              .map((item) => `- ${item}`)
              .join("\n")}`
          );
        }

        const cta = String(data?.cta || "").trim();
        if (cta) parts.push(cta);

        return parts.join("\n\n").trim();
      }

      function updateListperfectlyDescription(data) {
        if (!data) return;
        const next = buildListperfectlyDescription(data);
        data.listperfectly_description = next;
        const input = fieldInputMap.listperfectly_description;
        if (input && input.value !== next) {
          input.value = next;
          updateCharCounter("listperfectly_description");
        }
      }

      function buildSellerNotes(data, existingNotes) {
        const base =
          data?.purchase_date && data?.purchase_location
            ? `${data.purchase_date} Purchased from ${data.purchase_location}`
            : "";
        const lines = String(existingNotes || "")
          .split(/\n/)
          .map((line) => line.trim())
          .filter(Boolean);
        const extras = lines.filter(
          (line) => line !== base && line !== lastAutoNotes
        );
        if (!base) return extras.join("\n");
        return [base, ...extras].join("\n").trim();
      }

      function updateSellerNotes(data) {
        if (!data) return;
        const next = buildSellerNotes(data, data.notes);
        const base =
          data?.purchase_date && data?.purchase_location
            ? `${data.purchase_date} Purchased from ${data.purchase_location}`
            : "";
        lastAutoNotes = base;
        data.notes = next;
        const input = fieldInputMap.notes;
        if (input && input.value !== next) {
          input.value = next;
        }
      }

      function normalizeMsrp(data) {
        if (!data) return;
        const priceRaw = String(data.buyer_pays_shipping_price || "").trim();
        const msrpRaw = String(data.msrp || "").trim();
        const price = parseMoney(priceRaw);
        const msrp = parseMoney(msrpRaw);
        if (price === null) return;
        if (msrp === null || msrp < price) {
          const next = priceRaw || price.toFixed(2);
          data.msrp = next;
          const input = fieldInputMap.msrp;
          if (input && input.value !== next) {
            input.value = next;
          }
        }
      }

      function ensureIncludeToggle(input, toggleId, labelText) {
        if (!input) return null;
        const existing = document.getElementById(toggleId);
        if (existing) return existing;
        const field = input.closest(".field");
        if (!field) return null;
        const row = document.createElement("div");
        row.className = "row";
        const label = document.createElement("label");
        label.className = "inline-check";
        const checkbox = document.createElement("input");
        checkbox.type = "checkbox";
        checkbox.id = toggleId;
        checkbox.checked = Boolean(String(input.value || "").trim());
        checkbox.addEventListener("change", () => {
          checkbox.dataset.manual = "true";
        });
        label.appendChild(checkbox);
        label.appendChild(document.createTextNode(` ${labelText}`));
        row.appendChild(label);
        field.appendChild(row);
        measurementTogglePairs.push({ toggle: checkbox, input });
        return checkbox;
      }

      function applyIncludeDefaultsFromInputs() {
        if (includeDefaultsApplied) return;
        measurementTogglePairs.forEach(({ toggle, input }) => {
          if (!toggle || !input) return;
          toggle.checked = Boolean(String(input.value || "").trim());
          toggle.dataset.manual = "false";
        });
        includeDefaultsApplied = true;
      }

      function updateIncludeToggleForInput(input) {
        if (!input) return;
        const pair = measurementTogglePairs.find(
          (item) => item.input === input
        );
        if (!pair || !pair.toggle) return;
        const hasValue = Boolean(String(input.value || "").trim());
        if (!hasValue) {
          pair.toggle.checked = false;
          pair.toggle.dataset.manual = "false";
          return;
        }
        if (pair.toggle.dataset.manual === "true" && !pair.toggle.checked) {
          return;
        }
        pair.toggle.checked = true;
      }

      function initMeasurementToggles() {
        includeToggles.size = ensureIncludeToggle(
          sizeUsInput,
          "sizeIncludeToggle",
          "Include Size/Fit in measurements"
        );
        includeToggles.outsoleLength = ensureIncludeToggle(
          outsoleLengthInput,
          "outsoleLengthInclude",
          "Include"
        );
        includeToggles.outsoleWidth = ensureIncludeToggle(
          outsoleWidthInput,
          "outsoleWidthInclude",
          "Include"
        );
        includeToggles.insoleLength = ensureIncludeToggle(
          insoleLengthInput,
          "insoleLengthInclude",
          "Include"
        );
        includeToggles.insoleWidth = ensureIncludeToggle(
          insoleWidthInput,
          "insoleWidthInclude",
          "Include"
        );
        includeToggles.heelHeight = ensureIncludeToggle(
          heelHeightInput,
          "heelHeightInclude",
          "Include"
        );
        includeToggles.platformHeight = ensureIncludeToggle(
          platformHeightInput,
          "platformHeightInclude",
          "Include"
        );
        includeToggles.toeBoxHeight = ensureIncludeToggle(
          toeBoxHeightInput,
          "toeBoxHeightInclude",
          "Include"
        );
        includeToggles.weight = ensureIncludeToggle(
          weightValueInput,
          "weightInclude",
          "Include"
        );
        includeToggles.shaftHeight = ensureIncludeToggle(
          shaftHeightInput,
          "shaftHeightInclude",
          "Include"
        );
        includeToggles.shaftCirc = ensureIncludeToggle(
          shaftCircInput,
          "shaftCircInclude",
          "Include"
        );
        includeToggles.calfCirc = ensureIncludeToggle(
          calfCircInput,
          "calfCircInclude",
          "Include"
        );
        includeToggles.garmentChest = ensureIncludeToggle(
          garmentChestInput,
          "garmentChestInclude",
          "Include"
        );
        includeToggles.garmentLength = ensureIncludeToggle(
          garmentLengthInput,
          "garmentLengthInclude",
          "Include"
        );
        includeToggles.garmentShoulder = ensureIncludeToggle(
          garmentShoulderInput,
          "garmentShoulderInclude",
          "Include"
        );
        includeToggles.garmentSleeve = ensureIncludeToggle(
          garmentSleeveInput,
          "garmentSleeveInclude",
          "Include"
        );
        includeToggles.garmentWaist = ensureIncludeToggle(
          garmentWaistInput,
          "garmentWaistInclude",
          "Include"
        );
        includeToggles.garmentInseam = ensureIncludeToggle(
          garmentInseamInput,
          "garmentInseamInclude",
          "Include"
        );
        includeToggles.garmentRise = ensureIncludeToggle(
          garmentRiseInput,
          "garmentRiseInclude",
          "Include"
        );
        includeToggles.garmentHip = ensureIncludeToggle(
          garmentHipInput,
          "garmentHipInclude",
          "Include"
        );
        includeToggles.standardLength = ensureIncludeToggle(
          standardLengthInput,
          "standardLengthInclude",
          "Include"
        );
        includeToggles.standardWidth = ensureIncludeToggle(
          standardWidthInput,
          "standardWidthInclude",
          "Include"
        );
        includeToggles.standardHeight = ensureIncludeToggle(
          standardHeightInput,
          "standardHeightInclude",
          "Include"
        );
      }

      function isIncluded(toggle) {
        return !toggle || toggle.checked;
      }

      function parseNumber(value) {
        const parsed = Number.parseFloat(String(value || ""));
        return Number.isFinite(parsed) ? parsed : null;
      }

      function parseMoney(value) {
        const cleaned = String(value || "").replace(/[^0-9.]/g, "");
        const parsed = Number.parseFloat(cleaned);
        return Number.isFinite(parsed) ? parsed : null;
      }

      function formatSizeValue(value, estimated, verified) {
        if (value === null) return null;
        const text = formatNumber(value, 1);
        if (verified) return text;
        return estimated ? `~${text}` : text;
      }

      function getSizeOffsets(data) {
        const intended = Array.isArray(data?.intended_for)
          ? data.intended_for.map((item) => String(item).toLowerCase())
          : [];
        const isWomen = intended.includes("women");
        if (isWomen) {
          return { usToUk: -2, usToEu: 31 };
        }
        return { usToUk: -1, usToEu: 33 };
      }

      function convertSizeValues(raw, offsets) {
        let { us, uk, eu } = raw;
        let estimated = { us: false, uk: false, eu: false };
        if (us !== null) {
          if (uk === null) {
            uk = us + offsets.usToUk;
            estimated.uk = true;
          }
          if (eu === null) {
            eu = us + offsets.usToEu;
            estimated.eu = true;
          }
        } else if (uk !== null) {
          us = uk - offsets.usToUk;
          estimated.us = true;
          if (eu === null) {
            eu = us + offsets.usToEu;
            estimated.eu = true;
          }
        } else if (eu !== null) {
          us = eu - offsets.usToEu;
          estimated.us = true;
          uk = us + offsets.usToUk;
          estimated.uk = true;
        }
        return { us, uk, eu, estimated };
      }

      function applySizeConversions(data) {
        const raw = {
          us: parseNumber(sizeUsInput?.value),
          uk: parseNumber(sizeUkInput?.value),
          eu: parseNumber(sizeEuInput?.value),
        };
        const offsets = getSizeOffsets(data);
        const values = convertSizeValues(raw, offsets);
        setInputValue(sizeUsInput, values.us);
        setInputValue(sizeUkInput, values.uk);
        setInputValue(sizeEuInput, values.eu);
        return values;
      }

      function normalizeWidthLabel(value) {
        const raw = String(value || "").trim();
        if (!raw) return "";
        const lower = raw.toLowerCase();
        if (lower === "reg" || lower === "regular" || lower === "m") {
          return "Reg";
        }
        if (lower.includes("narrow")) return "Narrow";
        if (
          lower.includes("xx") ||
          lower.includes("4e") ||
          lower.includes("eeee")
        ) {
          return "XXWide";
        }
        if (lower.includes("extra")) return "Extra Wide";
        if (lower.includes("wide") || lower === "w") return "Wide";
        const compact = lower.replace(/[^a-z0-9]/g, "");
        if (compact === "d") return "Reg";
        if (compact === "b" || compact === "c") return "Narrow";
        if (compact === "e" || compact === "ee" || compact === "2e") {
          return "Wide";
        }
        if (compact === "eee" || compact === "3e") return "Extra Wide";
        if (compact === "4e" || compact === "eeee") return "XXWide";
        return raw;
      }

      function formatWidthText(raw) {
        const cleaned = String(raw || "").trim();
        const label = normalizeWidthLabel(cleaned);
        if (!label) return "Reg";
        if (!cleaned) return label;
        const compact = cleaned.replace(/[^a-z0-9]/gi, "");
        const isCodeOnly = /^[a-z0-9]+$/i.test(compact) && compact.length <= 3;
        if (isCodeOnly && label !== cleaned) {
          return `${cleaned} (${label})`;
        }
        return label;
      }

      function formatNumber(value, decimals) {
        const factor = 10 ** decimals;
        const rounded = Math.round(value * factor) / factor;
        const fixed = rounded.toFixed(decimals);
        return fixed.replace(/\.0+$/, "");
      }

      function formatInches(value, verified) {
        const text = `${formatNumber(value, 1)} in`;
        return verified ? text : `~${text}`;
      }

      function formatCentimeters(value) {
        return `${formatNumber(value * 2.54, 1)} cm`;
      }

      function formatPounds(value, verified) {
        const text = `${formatNumber(value, 2)} lb`;
        return verified ? text : `~${text}`;
      }

      function formatKilograms(value) {
        return `${formatNumber(value * 0.453592, 2)} kg`;
      }

      function addMeasurementLine(
        label,
        inches,
        lines,
        imperial,
        metric,
        verified
      ) {
        if (inches === null) return;
        const inText = formatInches(inches, verified);
        const cmText = formatCentimeters(inches);
        lines.push(`${label}: ${inText} (${cmText})`);
        imperial.push(`${label}: ${inText}`);
        metric.push(`${label}: ${cmText}`);
      }

      function addWeightLine(label, pounds, lines, imperial, metric, verified) {
        if (pounds === null) return;
        const lbText = formatPounds(pounds, verified);
        const kgText = formatKilograms(pounds);
        lines.push(`${label}: ${lbText} (${kgText})`);
        imperial.push(`${label}: ${lbText}`);
        metric.push(`${label}: ${kgText}`);
      }

      function buildSizeTagFromInputs(data) {
        const values = applySizeConversions(data);
        const width = String(sizeWidthInput?.value || "").trim();
        if (values.us === null && values.uk === null && values.eu === null) {
          return "";
        }
        const verified = measurementsVerifiedToggle?.checked;
        const usText = formatSizeValue(
          values.us,
          values.estimated?.us,
          verified
        );
        const ukText = formatSizeValue(
          values.uk,
          values.estimated?.uk,
          verified
        );
        const euText = formatSizeValue(
          values.eu,
          values.estimated?.eu,
          verified
        );
        const parts = [];
        if (usText !== null) parts.push(`US ${usText}`);
        if (ukText !== null) parts.push(`UK ${ukText}`);
        if (euText !== null) parts.push(`EU ${euText}`);
        const widthText = formatWidthText(width);
        return `${parts.join(" / ")} / Width ${widthText}`;
      }

      function updateSizeOrFitFromHelper(data) {
        if (!data) return;
        const next = buildSizeTagFromInputs(data);
        const current = String(data.size_or_fit || "").trim();
        const hasPlaceholder = current.includes("__");
        const currentWidthMatch = current.match(/Width\s*([^)]+)/i);
        const currentWidthRaw = currentWidthMatch
          ? currentWidthMatch[1].trim()
          : "";
        const currentWidthFormatted = currentWidthRaw
          ? formatWidthText(currentWidthRaw)
          : "";
        const widthNeedsNormalize =
          currentWidthRaw && currentWidthFormatted !== currentWidthRaw;
        if (!next) {
          if (hasPlaceholder) {
            data.size_or_fit = "";
            lastAutoSize = "";
            const input = fieldInputMap.size_or_fit;
            if (input && input.value) {
              input.value = "";
            }
          }
          return;
        }
        if (
          current &&
          current !== lastAutoSize &&
          !hasPlaceholder &&
          !widthNeedsNormalize
        ) {
          return;
        }
        data.size_or_fit = next;
        lastAutoSize = next;
        const input = fieldInputMap.size_or_fit;
        if (input && input.value !== next) {
          input.value = next;
        }
      }

      function setFieldValue(key, value) {
        if (!currentData) return;
        currentData[key] = value;
        const input = fieldInputMap[key];
        if (!input) return;
        if (Array.isArray(value)) {
          input.value = value.join("\n");
        } else {
          input.value = value ?? "";
        }
        updateCharCounter(key);
      }

      function hasMeasurementInputs(values) {
        return Object.values(values).some((value) => value !== null);
      }

      function detectMeasurementTemplate(data) {
        const lines = Array.isArray(data?.measurements)
          ? data.measurements.join("\n").toLowerCase()
          : String(data?.measurements || "").toLowerCase();
        if (lines.includes("outsole") || lines.includes("insole")) {
          if (
            lines.includes("shaft") ||
            lines.includes("calf") ||
            lines.includes("opening")
          ) {
            return "boot";
          }
          return "shoe";
        }
        if (
          lines.includes("chest") ||
          lines.includes("waist") ||
          lines.includes("inseam") ||
          lines.includes("sleeve")
        ) {
          return "garment";
        }
        if (
          lines.includes("length") &&
          lines.includes("width") &&
          lines.includes("height")
        ) {
          return "standard";
        }
        return "shoe";
      }

      function getSelectedTemplate() {
        if (!measurementTemplateSelect) return "shoe";
        if (measurementTemplateSelect.value !== "auto") {
          return measurementTemplateSelect.value;
        }
        return detectMeasurementTemplate(currentData);
      }

      function updateMeasurementsFromHelper() {
        if (!currentData) return;
        const template = getSelectedTemplate();
        const values = {
          outsoleLength: parseNumber(outsoleLengthInput?.value),
          outsoleWidth: parseNumber(outsoleWidthInput?.value),
          insoleLength: parseNumber(insoleLengthInput?.value),
          insoleWidth: parseNumber(insoleWidthInput?.value),
          heelHeight: parseNumber(heelHeightInput?.value),
          platformHeight: parseNumber(platformHeightInput?.value),
          toeBoxHeight: parseNumber(toeBoxHeightInput?.value),
          shaftHeight: parseNumber(shaftHeightInput?.value),
          shaftCirc: parseNumber(shaftCircInput?.value),
          calfCirc: parseNumber(calfCircInput?.value),
          weightValue: parseNumber(weightValueInput?.value),
          garmentChest: parseNumber(garmentChestInput?.value),
          garmentLength: parseNumber(garmentLengthInput?.value),
          garmentShoulder: parseNumber(garmentShoulderInput?.value),
          garmentSleeve: parseNumber(garmentSleeveInput?.value),
          garmentWaist: parseNumber(garmentWaistInput?.value),
          garmentInseam: parseNumber(garmentInseamInput?.value),
          garmentRise: parseNumber(garmentRiseInput?.value),
          garmentHip: parseNumber(garmentHipInput?.value),
          standardLength: parseNumber(standardLengthInput?.value),
          standardWidth: parseNumber(standardWidthInput?.value),
          standardHeight: parseNumber(standardHeightInput?.value),
        };

        if (!hasMeasurementInputs(values)) return;

        const lines = [];
        const imperial = [];
        const metric = [];
        const verified = measurementsVerifiedToggle?.checked;

        const sizeTag = String(currentData.size_or_fit || "").trim();
        if (sizeTag && isIncluded(includeToggles.size)) {
          lines.push(`Size / Fit: ${sizeTag}`);
        }

        if (template === "shoe" || template === "boot") {
          if (isIncluded(includeToggles.outsoleLength)) {
            addMeasurementLine(
              "Outsole length (heel-to-toe)",
              values.outsoleLength,
              lines,
              imperial,
              metric,
              verified
            );
          }
          if (isIncluded(includeToggles.outsoleWidth)) {
            addMeasurementLine(
              "Outsole width (widest)",
              values.outsoleWidth,
              lines,
              imperial,
              metric,
              verified
            );
          }
          if (isIncluded(includeToggles.insoleLength)) {
            addMeasurementLine(
              "Insole length (heel to toe)",
              values.insoleLength,
              lines,
              imperial,
              metric,
              verified
            );
          }
          if (isIncluded(includeToggles.insoleWidth)) {
            addMeasurementLine(
              "Insole width (ball area)",
              values.insoleWidth,
              lines,
              imperial,
              metric,
              verified
            );
          }
          if (isIncluded(includeToggles.heelHeight)) {
            addMeasurementLine(
              "Heel height",
              values.heelHeight,
              lines,
              imperial,
              metric,
              verified
            );
          }
          if (isIncluded(includeToggles.platformHeight)) {
            addMeasurementLine(
              "Platform height (forefoot)",
              values.platformHeight,
              lines,
              imperial,
              metric,
              verified
            );
          }
          if (isIncluded(includeToggles.toeBoxHeight)) {
            addMeasurementLine(
              "Toe box height",
              values.toeBoxHeight,
              lines,
              imperial,
              metric,
              verified
            );
          }

          if (template === "boot") {
            if (isIncluded(includeToggles.shaftHeight)) {
              addMeasurementLine(
                "Shaft height (from outsole)",
                values.shaftHeight,
                lines,
                imperial,
                metric,
                verified
              );
            }
            if (isIncluded(includeToggles.shaftCirc)) {
              addMeasurementLine(
                "Shaft opening (circumference)",
                values.shaftCirc,
                lines,
                imperial,
                metric,
                verified
              );
            }
            if (isIncluded(includeToggles.calfCirc)) {
              addMeasurementLine(
                "Calf circumference (widest point)",
                values.calfCirc,
                lines,
                imperial,
                metric,
                verified
              );
            }
          }

          if (
            values.weightValue !== null &&
            isIncluded(includeToggles.weight)
          ) {
            const weightLabel =
              weightPerSelect?.value === "boot"
                ? "Weight (per boot)"
                : "Weight (pair)";
            addWeightLine(
              weightLabel,
              values.weightValue,
              lines,
              imperial,
              metric,
              verified
            );
          }
        }

        if (template === "garment") {
          if (isIncluded(includeToggles.garmentChest)) {
            addMeasurementLine(
              "Chest (pit to pit)",
              values.garmentChest,
              lines,
              imperial,
              metric,
              verified
            );
          }
          if (isIncluded(includeToggles.garmentLength)) {
            addMeasurementLine(
              "Length (shoulder to hem)",
              values.garmentLength,
              lines,
              imperial,
              metric,
              verified
            );
          }
          if (isIncluded(includeToggles.garmentShoulder)) {
            addMeasurementLine(
              "Shoulder width",
              values.garmentShoulder,
              lines,
              imperial,
              metric,
              verified
            );
          }
          if (isIncluded(includeToggles.garmentSleeve)) {
            addMeasurementLine(
              "Sleeve length",
              values.garmentSleeve,
              lines,
              imperial,
              metric,
              verified
            );
          }
          if (isIncluded(includeToggles.garmentWaist)) {
            addMeasurementLine(
              "Waist",
              values.garmentWaist,
              lines,
              imperial,
              metric,
              verified
            );
          }
          if (isIncluded(includeToggles.garmentInseam)) {
            addMeasurementLine(
              "Inseam",
              values.garmentInseam,
              lines,
              imperial,
              metric,
              verified
            );
          }
          if (isIncluded(includeToggles.garmentRise)) {
            addMeasurementLine(
              "Rise",
              values.garmentRise,
              lines,
              imperial,
              metric,
              verified
            );
          }
          if (isIncluded(includeToggles.garmentHip)) {
            addMeasurementLine(
              "Hip",
              values.garmentHip,
              lines,
              imperial,
              metric,
              verified
            );
          }
        }

        if (template === "standard") {
          if (isIncluded(includeToggles.standardLength)) {
            addMeasurementLine(
              "Length",
              values.standardLength,
              lines,
              imperial,
              metric,
              verified
            );
          }
          if (isIncluded(includeToggles.standardWidth)) {
            addMeasurementLine(
              "Width",
              values.standardWidth,
              lines,
              imperial,
              metric,
              verified
            );
          }
          if (isIncluded(includeToggles.standardHeight)) {
            addMeasurementLine(
              "Height",
              values.standardHeight,
              lines,
              imperial,
              metric,
              verified
            );
          }
        }

        setFieldValue("measurements", lines);
        setFieldValue("measurements_imperial", imperial);
        setFieldValue("measurements_metric", metric);
        updateListperfectlyDescription(currentData);
        saveSession();
      }

      function toggleMeasurementFields() {
        if (!measurementTemplateSelect) return;
        const template =
          measurementTemplateSelect.value === "auto"
            ? detectMeasurementTemplate(currentData)
            : measurementTemplateSelect.value;
        if (shoeFields) {
          shoeFields.style.display =
            template === "shoe" || template === "boot" ? "block" : "none";
        }
        if (bootFields) {
          bootFields.style.display = template === "boot" ? "block" : "none";
        }
        if (garmentFields) {
          garmentFields.style.display =
            template === "garment" ? "block" : "none";
        }
        if (standardFields) {
          standardFields.style.display =
            template === "standard" ? "block" : "none";
        }
      }

      function extractInches(line) {
        const match = String(line || "").match(/:\s*~?([\d.]+)\s*in\b/i);
        return match ? Number.parseFloat(match[1]) : null;
      }

      function extractPounds(line) {
        const match = String(line || "").match(/:\s*~?([\d.]+)\s*lb\b/i);
        return match ? Number.parseFloat(match[1]) : null;
      }

      function setInputValue(input, value) {
        if (!input || value === null || Number.isNaN(value)) return;
        if (String(input.value || "").trim()) return;
        input.value = value;
      }

      function populateMeasurementHelperFromData(data) {
        if (!data) return;
        const lines = Array.isArray(data.measurements)
          ? data.measurements
          : parseList(data.measurements);
        if (!lines.length) return;

        const lineMap = new Map();
        lines.forEach((line) => {
          const [label] = String(line).split(":");
          if (!label) return;
          lineMap.set(label.trim().toLowerCase(), line);
        });

        const setFromLabel = (label, input, parser) => {
          const line = lineMap.get(label.toLowerCase());
          if (!line) return;
          const value = parser(line);
          setInputValue(input, value);
        };

        setFromLabel(
          "Outsole length (heel-to-toe)",
          outsoleLengthInput,
          extractInches
        );
        setFromLabel(
          "Outsole width (widest)",
          outsoleWidthInput,
          extractInches
        );
        setFromLabel(
          "Insole length (heel to toe)",
          insoleLengthInput,
          extractInches
        );
        setFromLabel(
          "Insole width (ball area)",
          insoleWidthInput,
          extractInches
        );
        setFromLabel("Heel height", heelHeightInput, extractInches);
        setFromLabel(
          "Platform height (forefoot)",
          platformHeightInput,
          extractInches
        );
        setFromLabel("Toe box height", toeBoxHeightInput, extractInches);
        setFromLabel(
          "Shaft height (from outsole)",
          shaftHeightInput,
          extractInches
        );
        setFromLabel(
          "Shaft opening (circumference)",
          shaftCircInput,
          extractInches
        );
        setFromLabel(
          "Calf circumference (widest point)",
          calfCircInput,
          extractInches
        );
        setFromLabel("Chest (pit to pit)", garmentChestInput, extractInches);
        setFromLabel(
          "Length (shoulder to hem)",
          garmentLengthInput,
          extractInches
        );
        setFromLabel("Shoulder width", garmentShoulderInput, extractInches);
        setFromLabel("Sleeve length", garmentSleeveInput, extractInches);
        setFromLabel("Waist", garmentWaistInput, extractInches);
        setFromLabel("Inseam", garmentInseamInput, extractInches);
        setFromLabel("Rise", garmentRiseInput, extractInches);
        setFromLabel("Hip", garmentHipInput, extractInches);
        setFromLabel("Length", standardLengthInput, extractInches);
        setFromLabel("Width", standardWidthInput, extractInches);
        setFromLabel("Height", standardHeightInput, extractInches);

        lines.forEach((line) => {
          if (!line.toLowerCase().includes("weight")) return;
          const pounds = extractPounds(line);
          setInputValue(weightValueInput, pounds);
          if (weightPerSelect) {
            if (line.toLowerCase().includes("per boot")) {
              weightPerSelect.value = "boot";
            } else {
              weightPerSelect.value = "pair";
            }
          }
        });

        const sizeText = String(data.size_or_fit || "");
        if (sizeText) {
          const usMatch = sizeText.match(/US\s*([0-9.]+)/i);
          const ukMatch = sizeText.match(/UK\s*([0-9.]+)/i);
          const euMatch = sizeText.match(/EU\s*([0-9.]+)/i);
          const widthMatch = sizeText.match(/Width\s*([A-Za-z0-9]+)/i);
          if (usMatch) setInputValue(sizeUsInput, usMatch[1]);
          if (ukMatch) setInputValue(sizeUkInput, ukMatch[1]);
          if (euMatch) setInputValue(sizeEuInput, euMatch[1]);
          if (widthMatch) setInputValue(sizeWidthInput, widthMatch[1]);
        }
        updateSizeOrFitFromHelper(data);
      }

      function sanitizePart(value) {
        return value
          .toLowerCase()
          .replace(/['",]/g, "")
          .replace(/\s+/g, "-")
          .replace(/-+/g, "-")
          .replace(/^-|-$/g, "");
      }

      function buildFilename(data) {
        const sku = data?.sku ? sanitizePart(String(data.sku)) : "";
        const title = data?.title
          ? sanitizePart(String(data.title))
          : "listing";
        const now = new Date();
        const yyyy = String(now.getFullYear());
        const mm = String(now.getMonth() + 1).padStart(2, "0");
        const dd = String(now.getDate()).padStart(2, "0");
        const hh = String(now.getHours()).padStart(2, "0");
        const min = String(now.getMinutes()).padStart(2, "0");
        const stamp = `${yyyy}${mm}${dd}-${hh}${min}`;
        const base = sku ? `${sku}_${title}` : title;
        return `${base}_${stamp}.json`;
      }

      function getLastSku() {
        return window.localStorage.getItem("moola_last_sku") || "";
      }

      function setLastSku(value) {
        if (value) {
          window.localStorage.setItem("moola_last_sku", value);
        }
      }

      function saveSession() {
        if (!currentData) return;
        try {
          window.localStorage.setItem(
            sessionStorageKey,
            JSON.stringify(currentData)
          );
        } catch (err) {
          // Ignore storage errors.
        }
      }

      function clearSession() {
        window.localStorage.removeItem(sessionStorageKey);
      }

      function resetToEmpty() {
        items = [];
        currentIndex = 0;
        currentData = null;
        skuConfirmed = false;
        fieldInputs = [];
        fieldInputMap = {};
        lpPanel.style.display = "none";
        measurementsHelperPanel.style.display = "none";
        platformPanel.style.display = "none";
        additionalPanel.style.display = "none";
        skuPanel.style.display = "none";
        lpFieldsContainer.innerHTML = "";
        ebayPlatformFieldsContainer.innerHTML = "";
        depopPlatformFieldsContainer.innerHTML = "";
        typesMiscFieldsContainer.innerHTML = "";
        otherPlatformFieldsContainer.innerHTML = "";
        additionalFieldsContainer.innerHTML = "";
        downloadBtn.disabled = true;
        if (previewBtn) previewBtn.disabled = true;
        if (mergeBtn) mergeBtn.disabled = true;
        prevBtn.disabled = true;
        nextBtn.disabled = true;
        if (fileInput) fileInput.value = "";
        updateStatus();
      }

      function loadSession() {
        const raw = window.localStorage.getItem(sessionStorageKey);
        if (!raw) return false;
        try {
          const data = JSON.parse(raw);
          items = [
            {
              name: "Recovered session",
              data,
              skuConfirmed: Boolean(data?.sku),
            },
          ];
          currentIndex = 0;
          skuPanel.style.display = "block";
          loadCurrent();
          return true;
        } catch (err) {
          return false;
        }
      }

      function escapeHtml(value) {
        return String(value || "")
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/"/g, "&quot;")
          .replace(/'/g, "&#39;");
      }

      function toLines(value) {
        if (!value) return [];
        if (Array.isArray(value)) {
          return value.map((item) => String(item).trim()).filter(Boolean);
        }
        return String(value)
          .split(/\n/)
          .map((line) => line.trim())
          .filter(Boolean);
      }

      function buildPreviewHtml(data) {
        const title = String(data?.title || "Listing Preview").trim();
        const sections = [];

        const readPreviewValue = (key) => {
          const input = fieldInputMap?.[key];
          if (input) return input.value;
          return data ? data[key] : "";
        };

        const addSection = (label, content) => {
          const lines = toLines(content);
          if (!lines.length) return;
          sections.push({
            label,
            html: `<pre>${escapeHtml(lines.join("\n"))}</pre>`,
          });
        };

        const formatPlatformsPreview = (value) => {
          if (Array.isArray(value)) {
            return value
              .map((item) => {
                const platform = String(item?.platform || "").trim();
                const reason = String(item?.reason || "").trim();
                return platform && reason
                  ? `${platform}: ${reason}`
                  : platform || reason;
              })
              .filter(Boolean);
          }
          return toLines(value);
        };

        const buildPlatformsPreviewBlock = () => {
          const rawPlatforms = readPreviewValue("platforms");
          const platforms = Array.isArray(rawPlatforms)
            ? rawPlatforms
            : parsePlatforms(rawPlatforms);
          const typesParts = getTypesParts({
            types_block: readPreviewValue("types_block"),
          });
          const lines = [];
          platforms.forEach((item) => {
            const platform = String(item?.platform || "").trim();
            const reason = String(item?.reason || "").trim();
            if (!platform && !reason) return;
            lines.push(platform || "Platform");
            if (reason) lines.push(`- Reason: ${reason}`);
            const lower = platform.toLowerCase();
            if (lower === "ebay" && typesParts.ebay) {
              lines.push(`- Types: ${typesParts.ebay}`);
            }
            if (lower === "depop" && typesParts.depop) {
              lines.push(`- Types: ${typesParts.depop}`);
            }
            if (lower === "depop" && typesParts.occasions) {
              lines.push(`- Occasions: ${typesParts.occasions}`);
            }
            if (lower === "depop" && typesParts.styles) {
              lines.push(`- Styles: ${typesParts.styles}`);
            }
            lines.push("");
          });
          while (lines.length && lines[lines.length - 1] === "") {
            lines.pop();
          }
          return lines;
        };

        addSection("Hook", readPreviewValue("hook"));
        addSection("Description", readPreviewValue("description"));
        addSection("Included Items", readPreviewValue("included_items"));
        addSection("Material", readPreviewValue("material"));
        addSection("Country of Origin", readPreviewValue("country_of_origin"));
        addSection("Measurements", readPreviewValue("measurements"));
        const tagsLine = readPreviewValue("tags_line");
        const styleTags = readPreviewValue("style_tags");
        const tagsSection = [];
        if (tagsLine) tagsSection.push(`Tags: ${tagsLine}`);
        if (styleTags) tagsSection.push(`Style tags: ${styleTags}`);
        addSection("Tags / Keywords", tagsSection);
        addSection("Condition", [
          `Condition status: ${readPreviewValue("condition_status")}`,
          `Pre-Owned condition: ${readPreviewValue("pre_owned_condition")}`,
          readPreviewValue("condition"),
        ]);
        addSection("Pricing", readPreviewValue("pricing_sentence"));
        const maxProfitTime = readPreviewValue("max_profit_time_to_sell");
        const minProfitTime = readPreviewValue("min_profit_time_to_sell");
        const profitLines = [
          `Max profit price: ${readPreviewValue("max_profit_price")}`,
          `Max profit estimate: ${readPreviewValue("max_profit_estimate")}`,
          `Max profit time to sell: ${maxProfitTime}`,
          `Min profit price: ${readPreviewValue("min_profit_price")}`,
          `Min profit estimate: ${readPreviewValue("min_profit_estimate")}`,
          `Min profit time to sell: ${minProfitTime}`,
        ];
        const offerRecommendation = readPreviewValue("offer_recommendation");
        if (offerRecommendation) {
          profitLines.push(offerRecommendation);
        }
        if (!maxProfitTime && !minProfitTime) {
          profitLines.push(
            `Time To Sell: ${readPreviewValue("time_to_sell_sentence")}`
          );
        }
        addSection("Profit Estimates", profitLines);
        addSection(
          "Shipping Estimate",
          readPreviewValue("shipping_estimate_sentence")
        );
        addSection("Fees Breakdown", [
          `Platform fees: ${readPreviewValue("platform_fee_estimate")}`,
          `Payment processing: ${readPreviewValue(
            "payment_processing_fee_estimate"
          )}`,
          `Labor: ${readPreviewValue("labor_cost_estimate")}`,
          `Fees or Other Costs: ${readPreviewValue("fees_or_other_costs")}`,
        ]);

        addSection("Platforms", buildPlatformsPreviewBlock());
        const miscTypes = [];
        const typesParts = getTypesParts({
          types_block: readPreviewValue("types_block"),
        });
        if (typesParts.misc?.length) {
          miscTypes.push(...typesParts.misc);
        }
        addSection("Misc", miscTypes);
        addSection("Seller Notes", readPreviewValue("notes"));

        const sectionsHtml = sections
          .map(
            (section) => `
          <section>
            <h2>${escapeHtml(section.label)}</h2>
            ${section.html}
          </section>`
          )
          .join("");

        return `<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>${escapeHtml(title || "Listing Preview")}</title>
    <style>
      :root {
        color-scheme: dark;
      }
      body {
        font-family: "Segoe UI", "Inter", Arial, sans-serif;
        margin: 24px;
        color: #f4edff;
        background: radial-gradient(circle at top, #2a104a 0%, #0f081b 55%, #0b0614 100%);
        font-size: 16px;
        line-height: 1.6;
        letter-spacing: 0.2px;
      }
      h1 {
        margin-bottom: 12px;
        font-size: 28px;
        color: #f7e9ff;
      }
      h2 {
        margin: 0 0 10px;
        font-size: 17px;
        color: #d7c3ff;
      }
      section {
        margin-bottom: 14px;
        padding-bottom: 12px;
        border-bottom: 1px solid #2b1a44;
      }
      section:last-of-type {
        border-bottom: none;
      }
      pre {
        white-space: pre-wrap;
        margin: 0;
        color: #f2eaff;
        background: transparent;
        padding: 0;
        border: none;
      }
      p {
        color: #e6dbff;
      }
    </style>
  </head>
  <body>
    <h1>${escapeHtml(title || "Listing Preview")}</h1>
    ${sectionsHtml || "<p>No preview content available.</p>"}
  </body>
</html>`;
      }

      function suggestNextSku() {
        const last = getLastSku();
        const lastNum = Number.parseInt(last, 10);
        if (Number.isFinite(lastNum)) {
          return String(lastNum + 1);
        }
        return "";
      }

      function updateSkuPanel(data) {
        skuPanel.style.display = "block";
        skuConfirmed = items[currentIndex]?.skuConfirmed || false;

        const existingSku = data?.sku || "";
        const suggested = existingSku || suggestNextSku();
        skuInput.value = suggested;
        skuInput.readOnly = skuConfirmed;

        if (skuConfirmed) {
          skuHint.textContent = `SKU confirmed: ${skuInput.value}.`;
        } else if (existingSku) {
          skuHint.textContent =
            "SKU loaded from file. Click OK to confirm or Change to edit.";
        } else if (suggested) {
          skuHint.textContent = `Suggested next SKU: ${suggested}`;
        } else {
          skuHint.textContent = "Enter your starting SKU and click OK.";
        }
      }

      function confirmSku() {
        if (!currentData) return;
        const value = skuInput.value.trim();
        if (!value) {
          skuHint.textContent = "SKU is empty. Enter a SKU and click OK.";
          return;
        }
        currentData.sku = value;
        setLastSku(value);
        skuConfirmed = true;
        if (items[currentIndex]) {
          items[currentIndex].skuConfirmed = true;
        }
        skuInput.readOnly = true;
        skuHint.textContent = `SKU set to ${value}.`;
        renderFields(currentData);
        saveSession();
      }

      function changeSku() {
        skuConfirmed = false;
        skuInput.readOnly = false;
        skuInput.focus();
        skuHint.textContent = "Enter a new SKU and click OK.";
      }

      skuOkBtn.addEventListener("click", confirmSku);
      skuChangeBtn.addEventListener("click", changeSku);

      function addField(field, data, container) {
        const fieldEl = document.createElement("div");
        fieldEl.className = "field";

        const fieldLabel = document.createElement("label");
        fieldLabel.textContent = field.label;
        fieldEl.appendChild(fieldLabel);

        const row = document.createElement("div");
        row.className = "row";

        const input = field.multiline
          ? document.createElement("textarea")
          : document.createElement("input");
        const rawValue = field.getValue
          ? field.getValue(data)
          : data
          ? data[field.key]
          : "";
        const displayValue = field.format
          ? field.format(rawValue)
          : toStringValue(rawValue);
        input.value = displayValue;
        input.readOnly = Boolean(field.readOnly) || !editMode;
        if (
          field.key === "listperfectly_description" &&
          input.tagName === "TEXTAREA"
        ) {
          input.style.minHeight = "200px";
        }
        row.appendChild(input);

        const button = document.createElement("button");
        button.textContent = "Copy";
        button.addEventListener("click", async () => {
          try {
            await navigator.clipboard.writeText(input.value);
            button.textContent = "Copied";
            setTimeout(() => (button.textContent = "Copy"), 1200);
          } catch (err) {
            button.textContent = "Copy failed";
            setTimeout(() => (button.textContent = "Copy"), 1200);
          }
        });
        row.appendChild(button);

        if (field.key) {
          fieldInputMap[field.key] = input;
          input.addEventListener("input", () => {
            if (!currentData) return;
            const parsedValue = field.parse
              ? field.parse(input.value)
              : input.value;
            if (field.setValue) {
              field.setValue(currentData, parsedValue);
            } else {
              currentData[field.key] = parsedValue;
            }
            if (field.key === "tags_line") {
              currentData.tags = parseList(input.value);
            }
            if (field.key === "platforms") {
              currentData.platforms = parsePlatforms(input.value);
            }
            if (
              [
                "measurements",
                "measurements_imperial",
                "measurements_metric",
              ].includes(field.key)
            ) {
              return;
            }
            if (
              [
                "hook",
                "description",
                "included_items",
                "measurements",
                "cta",
              ].includes(field.key)
            ) {
              updateListperfectlyDescription(currentData);
            }
            if (["buyer_pays_shipping_price", "msrp"].includes(field.key)) {
              normalizeMsrp(currentData);
            }
            if (["purchase_date", "purchase_location"].includes(field.key)) {
              updateSellerNotes(currentData);
            }
            items[currentIndex].data = currentData;
            saveSession();
            updateCharCounter(field.key);
          });
        }

        fieldEl.appendChild(row);
        if (field.key && field.countChars) {
          const counter = document.createElement("div");
          counter.className = "note";
          counter.id = `counter-${field.key}`;
          if (field.maxChars) {
            counter.setAttribute("data-max", String(field.maxChars));
          }
          const maxLabel = field.maxChars ? ` / ${field.maxChars}` : "";
          counter.textContent = `Characters: ${input.value.length}${maxLabel}`;
          fieldEl.appendChild(counter);
        }
        container.appendChild(fieldEl);
        fieldInputs.push(input);
      }

      function updateCharCounter(key) {
        if (!key) return;
        const counter = document.getElementById(`counter-${key}`);
        const input = fieldInputMap[key];
        if (!counter || !input) return;
        const max = counter.getAttribute("data-max");
        const maxLabel = max ? ` / ${max}` : "";
        counter.textContent = `Characters: ${input.value.length}${maxLabel}`;
      }

      function renderFields(data) {
        lpFieldsContainer.innerHTML = "";
        ebayPlatformFieldsContainer.innerHTML = "";
        depopPlatformFieldsContainer.innerHTML = "";
        typesMiscFieldsContainer.innerHTML = "";
        otherPlatformFieldsContainer.innerHTML = "";
        additionalFieldsContainer.innerHTML = "";
        fieldInputs = [];
        fieldInputMap = {};
        const listperfectlyFields = [
          { label: "SKU", key: "sku" },
          { label: "Title", key: "title", countChars: true, maxChars: 80 },
          {
            label: "Short Description (ListPerfectly)",
            key: "listperfectly_description",
            multiline: true,
            readOnly: true,
            countChars: true,
          },
          { label: "Hook", key: "hook" },
          { label: "Description", key: "description", multiline: true },
          {
            label: "Included Items",
            key: "included_items",
            multiline: true,
            format: (value) => toStringValue(value),
            parse: (value) => parseLines(value),
          },
          {
            label: "Measurements (Combined)",
            key: "measurements",
            multiline: true,
            format: (value) => toStringValue(value),
            parse: (value) => parseList(value),
          },
          {
            label: "Measurements (Imperial)",
            key: "measurements_imperial",
            multiline: true,
            format: (value) => toStringValue(value),
            parse: (value) => parseList(value),
          },
          {
            label: "Measurements (Metric)",
            key: "measurements_metric",
            multiline: true,
            format: (value) => toStringValue(value),
            parse: (value) => parseList(value),
          },
          { label: "CTA", key: "cta" },
          { label: "Brand / Maker", key: "brand" },
          {
            label: "Color Shade",
            key: "color",
            format: (value) => normalizeColorTags(value),
            parse: (value) => normalizeColorTags(value),
          },
          { label: "Material", key: "material" },
          { label: "Country of Origin", key: "country_of_origin" },
          { label: "Style / Features", key: "style_features" },
          { label: "Size or Fit", key: "size_or_fit" },
          { label: "Tags line", key: "tags_line" },
          {
            label: "Style Tags (boho, mid century modern, etc.)",
            key: "style_tags",
            format: (value) =>
              Array.isArray(value) ? value.join(", ") : toStringValue(value),
            parse: (value) => parseList(value),
          },
          { label: "Condition Status", key: "condition_status" },
          {
            label: "Pre-Owned Condition (Like New/Good/Fair/Poor/None)",
            key: "pre_owned_condition",
          },
          { label: "Condition Notes", key: "condition", multiline: true },
          {
            label: "Buyer pays shipping price",
            key: "buyer_pays_shipping_price",
          },
          { label: "COGS", key: "cogs" },
          { label: "MSRP", key: "msrp" },
          { label: "UPC", key: "upc" },
          { label: "Quantity", key: "quantity" },
          {
            label: "Intended For",
            key: "intended_for",
            multiline: true,
            format: (value) =>
              Array.isArray(value) ? value.join(", ") : toStringValue(value),
            parse: (value) => parseList(value),
          },
          { label: "Shipping Weight (lb)", key: "shipping_weight_lb" },
          { label: "Shipping Weight (oz)", key: "shipping_weight_oz" },
          { label: "Package Length (in)", key: "package_length" },
          { label: "Package Width (in)", key: "package_width" },
          { label: "Package Height (in)", key: "package_height" },
          { label: "Shipping ZIP", key: "shipping_zip" },
          { label: "Seller Notes", key: "notes", multiline: true },
          { label: "Purchase Date", key: "purchase_date" },
          { label: "Purchase Location", key: "purchase_location" },
        ];

        const ebayPlatformFields = [
          {
            label: "Ebay Reason",
            multiline: true,
            getValue: (data) => getPlatformReason(data, "eBay"),
            setValue: (data, value) => setPlatformReason(data, "eBay", value),
          },
          {
            label: "Ebay Types",
            multiline: true,
            getValue: (data) => getTypesParts(data).ebay,
            setValue: (data, value) => setTypesPart(data, "ebay", value),
          },
        ];

        const depopPlatformFields = [
          {
            label: "Depop Reason",
            multiline: true,
            getValue: (data) => getPlatformReason(data, "Depop"),
            setValue: (data, value) => setPlatformReason(data, "Depop", value),
          },
          {
            label: "Depop Types",
            multiline: true,
            getValue: (data) => getTypesParts(data).depop,
            setValue: (data, value) => setTypesPart(data, "depop", value),
          },
        ];

        const miscTypesFields = [
          {
            label: "Occasions",
            multiline: true,
            getValue: (data) => getTypesParts(data).occasions,
            setValue: (data, value) => setTypesPart(data, "occasions", value),
          },
          {
            label: "Styles",
            multiline: true,
            getValue: (data) => getTypesParts(data).styles,
            setValue: (data, value) => setTypesPart(data, "styles", value),
          },
        ];

        const otherPlatformFields = [
          {
            label: "Etsy reason",
            multiline: true,
            getValue: (data) => getPlatformReason(data, "Etsy"),
            setValue: (data, value) => setPlatformReason(data, "Etsy", value),
          },
          {
            label: "Facebook Marketplace reason",
            multiline: true,
            getValue: (data) => getPlatformReason(data, "Facebook Marketplace"),
            setValue: (data, value) =>
              setPlatformReason(data, "Facebook Marketplace", value),
          },
          {
            label: "Mercari reason",
            multiline: true,
            getValue: (data) => getPlatformReason(data, "Mercari"),
            setValue: (data, value) =>
              setPlatformReason(data, "Mercari", value),
          },
          {
            label: "Poshmark reason",
            multiline: true,
            getValue: (data) => getPlatformReason(data, "Poshmark"),
            setValue: (data, value) =>
              setPlatformReason(data, "Poshmark", value),
          },
          {
            label: "Grailed reason",
            multiline: true,
            getValue: (data) => getPlatformReason(data, "Grailed"),
            setValue: (data, value) =>
              setPlatformReason(data, "Grailed", value),
          },
          {
            label: "Depop reason",
            multiline: true,
            getValue: (data) => getPlatformReason(data, "Depop"),
            setValue: (data, value) => setPlatformReason(data, "Depop", value),
          },
          {
            label: "Shopify reason",
            multiline: true,
            getValue: (data) => getPlatformReason(data, "Shopify"),
            setValue: (data, value) =>
              setPlatformReason(data, "Shopify", value),
          },
          {
            label: "Vestiaire Collective reason",
            multiline: true,
            getValue: (data) => getPlatformReason(data, "Vestiaire Collective"),
            setValue: (data, value) =>
              setPlatformReason(data, "Vestiaire Collective", value),
          },
          {
            label: "Vinted reason",
            multiline: true,
            getValue: (data) => getPlatformReason(data, "Vinted"),
            setValue: (data, value) => setPlatformReason(data, "Vinted", value),
          },
          {
            label: "Whatnot reason",
            multiline: true,
            getValue: (data) => getPlatformReason(data, "Whatnot"),
            setValue: (data, value) =>
              setPlatformReason(data, "Whatnot", value),
          },
        ];

        const additionalFields = [
          { label: "Listing body", key: "listing_body", multiline: true },
          {
            label: "Pricing sentence",
            key: "pricing_sentence",
            multiline: true,
          },
          { label: "Free shipping price", key: "free_shipping_price" },
          {
            label: "Shipping estimate sentence",
            key: "shipping_estimate_sentence",
            multiline: true,
          },
          { label: "Shipping cost estimate", key: "shipping_cost_estimate" },
          { label: "Platform fee estimate", key: "platform_fee_estimate" },
          {
            label: "Payment processing fee estimate",
            key: "payment_processing_fee_estimate",
          },
          { label: "Labor cost estimate", key: "labor_cost_estimate" },
          { label: "Fees or Other Costs", key: "fees_or_other_costs" },
          { label: "Max profit price", key: "max_profit_price" },
          { label: "Max profit estimate", key: "max_profit_estimate" },
          { label: "Max profit time to sell", key: "max_profit_time_to_sell" },
          { label: "Min profit price", key: "min_profit_price" },
          { label: "Min profit estimate", key: "min_profit_estimate" },
          { label: "Min profit time to sell", key: "min_profit_time_to_sell" },
          { label: "Offer recommendation", key: "offer_recommendation" },
          {
            label: "Time-to-sell sentence",
            key: "time_to_sell_sentence",
            multiline: true,
          },
          { label: "Question", key: "question" },
        ];

        listperfectlyFields.forEach((field) =>
          addField(field, data, lpFieldsContainer)
        );
        ebayPlatformFields.forEach((field) =>
          addField(field, data, ebayPlatformFieldsContainer)
        );
        depopPlatformFields.forEach((field) =>
          addField(field, data, depopPlatformFieldsContainer)
        );
        miscTypesFields.forEach((field) =>
          addField(field, data, typesMiscFieldsContainer)
        );
        otherPlatformFields.forEach((field) =>
          addField(field, data, otherPlatformFieldsContainer)
        );
        additionalFields.forEach((field) =>
          addField(field, data, additionalFieldsContainer)
        );
        updateListperfectlyDescription(data);
        updateSellerNotes(data);
      }

      function updateFieldEditability() {
        fieldInputs.forEach((input) => {
          input.readOnly = !editMode;
        });
      }

      updateFieldEditability();
      initMeasurementToggles();

      function handleMeasurementInput() {
        const template = getSelectedTemplate();
        if (template === "shoe" || template === "boot") {
          updateSizeOrFitFromHelper(currentData);
        }
        updateMeasurementsFromHelper();
      }

      const measurementInputs = [
        sizeUsInput,
        sizeUkInput,
        sizeEuInput,
        sizeWidthInput,
        outsoleLengthInput,
        outsoleWidthInput,
        insoleLengthInput,
        insoleWidthInput,
        heelHeightInput,
        platformHeightInput,
        toeBoxHeightInput,
        weightValueInput,
        shaftHeightInput,
        shaftCircInput,
        calfCircInput,
        garmentChestInput,
        garmentLengthInput,
        garmentShoulderInput,
        garmentSleeveInput,
        garmentWaistInput,
        garmentInseamInput,
        garmentRiseInput,
        garmentHipInput,
        standardLengthInput,
        standardWidthInput,
        standardHeightInput,
      ];

      measurementInputs.forEach((input) => {
        if (!input) return;
        input.addEventListener("input", () => {
          updateIncludeToggleForInput(input);
          handleMeasurementInput();
        });
      });

      if (weightPerSelect) {
        weightPerSelect.addEventListener("change", handleMeasurementInput);
      }

      if (measurementTemplateSelect) {
        measurementTemplateSelect.addEventListener("change", () => {
          toggleMeasurementFields();
          handleMeasurementInput();
        });
      }

      if (measurementsVerifiedToggle) {
        measurementsVerifiedToggle.addEventListener("change", () => {
          updateMeasurementsFromHelper();
        });
      }

      if (saveVerifiedBtn) {
        saveVerifiedBtn.addEventListener("click", () => {
          if (measurementsVerifiedToggle) {
            measurementsVerifiedToggle.checked = true;
          }
          handleMeasurementInput();
        });
      }

      jsonBrowseBtn.addEventListener("click", () => {
        jsonPicker.click();
      });

      if (mergeBtn) {
        mergeBtn.addEventListener("click", () => {
          if (!currentData) return;
          if (mergePicker) mergePicker.click();
        });
      }

      if (mergePicker) {
        mergePicker.addEventListener("change", async () => {
          if (!currentData) return;
          const file = mergePicker.files && mergePicker.files[0];
          if (!file) return;
          try {
            const text = await file.text();
            const incoming = JSON.parse(text);
            if (!isLikelySameItem(currentData, incoming)) {
              status.textContent =
                "Merge skipped: selected file does not appear to match this listing.";
              return;
            }
            const changed = mergeMissingFields(currentData, incoming);
            if (!changed) {
              status.textContent = `Merge complete. No missing fields found in ${file.name}.`;
            } else {
              status.textContent = `Merged missing fields from ${file.name}.`;
            }
            items[currentIndex].data = currentData;
            renderFields(currentData);
            normalizeMsrp(currentData);
            updateListperfectlyDescription(currentData);
            updateSellerNotes(currentData);
            toggleMeasurementFields();
            populateMeasurementHelperFromData(currentData);
            applyIncludeDefaultsFromInputs();
            updateFieldEditability();
            saveSession();
            mergePicker.value = "";
          } catch (err) {
            status.textContent = `Could not parse JSON: ${file.name}`;
          }
        });
      }

      jsonPicker.addEventListener("change", () => {
        const file = jsonPicker.files && jsonPicker.files[0];
        if (!file) return;
        const currentPath = jsonPathInput.value.trim();
        const hasJsonPath = currentPath.toLowerCase().endsWith(".json");
        const baseFolder = hasJsonPath
          ? currentPath.slice(0, Math.max(0, currentPath.lastIndexOf("\\")))
          : currentPath.replace(/\\+$/g, "");
        const folderToUse = baseFolder || defaultJsonFolder;
        if (folderToUse) {
          jsonPathInput.value = `${folderToUse}\\${file.name}`;
        } else {
          jsonPathInput.value = file.name;
        }
        autofillNote.textContent = `Selected ${file.name}. Path was auto-filled; edit if needed.`;
        saveAutofillInputs();
      });

      function loadSavedAutofillInputs() {
        const savedProject = window.localStorage.getItem("moola_project_path");
        if (savedProject) {
          if (savedProject.includes("Moola-Matic")) {
            projectPathInput.value =
              "C:\\\\Users\\\\outdo\\\\Documents\\\\MOOLA-MATIC MINI";
            window.localStorage.setItem(
              "moola_project_path",
              projectPathInput.value
            );
          } else {
            projectPathInput.value = savedProject;
          }
        }
        if (!projectPathInput.value) {
          projectPathInput.value =
            "C:\\\\Users\\\\outdo\\\\Documents\\\\MOOLA-MATIC MINI";
        }
        jsonPathInput.value = "C:\\\\Users\\\\outdo\\\\Downloads";
        const current = jsonPathInput.value.trim();
        if (current.includes("\\")) {
          if (current.toLowerCase().endsWith(".json")) {
            defaultJsonFolder = current.slice(0, current.lastIndexOf("\\"));
          } else {
            defaultJsonFolder = current.replace(/\\+$/g, "");
          }
        }
      }

      function saveAutofillInputs() {
        if (projectPathInput.value) {
          window.localStorage.setItem(
            "moola_project_path",
            projectPathInput.value
          );
        }
        if (jsonPathInput.value) {
          window.localStorage.setItem("moola_json_path", jsonPathInput.value);
        }
      }

      function buildAutofillCommand() {
        const projectPath = projectPathInput.value.trim();
        const jsonPath = jsonPathInput.value.trim();
        if (!projectPath || !jsonPath) return "";
        const scriptPath = `${projectPath}\\playwright-assistant\\scripts\\run-playwright.js`;
        const selectorsPath = `${projectPath}\\playwright-assistant\\scripts\\selectors.json`;
        const userDataDir = `${projectPath}\\playwright-assistant\\.user-data`;
        return `node \"${scriptPath}\" --safe --json \"${jsonPath}\" --selectors \"${selectorsPath}\" --user-data-dir \"${userDataDir}\"`;
      }

      function isJsonFilePath(value) {
        return String(value || "")
          .trim()
          .toLowerCase()
          .endsWith(".json");
      }

      function ensureJsonPathIsFile() {
        const jsonPath = jsonPathInput.value.trim();
        if (!jsonPath) return false;
        if (isJsonFilePath(jsonPath)) return true;
        autofillNote.textContent =
          "Download the JSON first, then paste the full .json file path.";
        return false;
      }

      copyCmdBtn.addEventListener("click", async () => {
        saveAutofillInputs();
        if (!ensureJsonPathIsFile()) return;
        const cmd = buildAutofillCommand();
        if (!cmd) {
          autofillNote.textContent =
            "Enter the project path and JSON file path first.";
          return;
        }
        try {
          await navigator.clipboard.writeText(cmd);
          autofillNote.textContent = "Autofill command copied.";
        } catch (err) {
          autofillNote.textContent =
            "Could not copy. You can still download the .bat file.";
        }
      });

      downloadBatBtn.addEventListener("click", () => {
        saveAutofillInputs();
        if (!ensureJsonPathIsFile()) return;
        const cmd = buildAutofillCommand();
        if (!cmd) {
          autofillNote.textContent =
            "Enter the project path and JSON file path first.";
          return;
        }
        const content = `@echo off\r\n${cmd}\r\npause\r\n`;
        const blob = new Blob([content], { type: "text/plain" });
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        link.href = url;
        link.download = "run-autofill.bat";
        document.body.appendChild(link);
        link.click();
        link.remove();
        URL.revokeObjectURL(url);
        autofillNote.textContent =
          "run-autofill.bat downloaded. Double-click it to run.";
      });

      function updateStatus() {
        if (!items.length) {
          status.textContent = "No file loaded.";
          prevBtn.disabled = true;
          nextBtn.disabled = true;
          return;
        }
        const current = items[currentIndex];
        status.textContent = `Loaded ${items.length} file(s). Viewing ${
          currentIndex + 1
        } of ${items.length}: ${current.name}`;
        prevBtn.disabled = currentIndex === 0;
        nextBtn.disabled = currentIndex === items.length - 1;
      }

      function loadCurrent() {
        if (!items.length) return;
        includeDefaultsApplied = false;
        currentData = items[currentIndex].data;
        lpPanel.style.display = "block";
        measurementsHelperPanel.style.display = "block";
        platformPanel.style.display = "block";
        additionalPanel.style.display = "block";
        updateSkuPanel(currentData);
        renderFields(currentData);
        normalizeMsrp(currentData);
        updateFieldEditability();
        toggleMeasurementFields();
        populateMeasurementHelperFromData(currentData);
        applyIncludeDefaultsFromInputs();
        downloadBtn.disabled = false;
        if (previewBtn) previewBtn.disabled = false;
        if (mergeBtn) mergeBtn.disabled = false;
        updateStatus();
        saveSession();
      }

      prevBtn.addEventListener("click", () => {
        if (currentIndex > 0) {
          currentIndex -= 1;
          loadCurrent();
        }
      });

      nextBtn.addEventListener("click", () => {
        if (!skuConfirmed) {
          skuHint.textContent = "Confirm SKU first, then click Next.";
          return;
        }
        if (currentIndex < items.length - 1) {
          currentIndex += 1;
          loadCurrent();
        }
      });

      fileInput.addEventListener("change", async (event) => {
        const files = Array.from(event.target.files || []);
        if (!files.length) return;
        clearSession();
        items = [];
        for (const file of files) {
          try {
            const text = await file.text();
            const data = JSON.parse(text);
            items.push({ name: file.name, data, skuConfirmed: false });
          } catch (err) {
            status.textContent = `Could not parse JSON: ${file.name}`;
          }
        }
        if (!items.length) {
          resetToEmpty();
          return;
        }
        currentIndex = 0;
        skuPanel.style.display = "block";
        loadCurrent();
      });

      loadSavedAutofillInputs();
      loadSession();

      downloadBtn.addEventListener("click", () => {
        if (!currentData) return;
        normalizeMsrp(currentData);
        updateListperfectlyDescription(currentData);
        const filename = buildFilename(currentData);
        const blob = new Blob([JSON.stringify(currentData, null, 2)], {
          type: "application/json",
        });
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        link.href = url;
        link.download = filename;
        document.body.appendChild(link);
        link.click();
        link.remove();
        URL.revokeObjectURL(url);
        jsonPathInput.value = `C:\\\\Users\\\\outdo\\\\Downloads\\\\${filename}`;
        saveAutofillInputs();
      });

      if (previewBtn) {
        previewBtn.addEventListener("click", () => {
          if (!currentData) return;
          const html = buildPreviewHtml(currentData);
          const win = window.open("", "_blank");
          if (!win) return;
          win.document.write(html);
          win.document.close();
        });
      }

      if (expandAllBtn) {
        expandAllBtn.addEventListener("click", () => {
          document.querySelectorAll("details.panel").forEach((panel) => {
            panel.open = true;
          });
        });
      }

      if (collapseAllBtn) {
        collapseAllBtn.addEventListener("click", () => {
          document.querySelectorAll("details.panel").forEach((panel) => {
            panel.open = false;
          });
        });
      }

      if (clearAllBtn) {
        clearAllBtn.addEventListener("click", () => {
          clearSession();
          resetToEmpty();
        });
      }
    </script>
  </body>
</html>
